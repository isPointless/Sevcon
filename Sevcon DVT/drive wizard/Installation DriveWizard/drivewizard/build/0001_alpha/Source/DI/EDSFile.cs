/*******************************************************************************
(C) COPYRIGHT Sevcon 2004

Project Reference UK0139

FILE
	$Revision:1.104$
	$Version:$
	$Author:ak$
	$ProjectName:DriveWizard$ 

	$RevDate:08/10/2008 14:02:40$
	$ModDate:08/10/2008 10:36:18$

ORIGINAL AUTHOR
    Alison King

DESCRIPTION
	This class provides the functionality to read a
    CANopen compliant EDS file and extract the object
    descriptions into the EDSObjectInfo data structure
    which is a suitable format for DW to build the replica
    of the object dictionary.

REFERENCES    

MODIFICATION HISTORY
    $Log:  36691: EDSFile.cs 

   Rev 1.104    08/10/2008 14:02:40  ak
 TRR COD0013 post-test fixes


   Rev 1.103    23/09/2008 23:14:50  ak
 UK0139.03 updates for CRR COD0013, ready for testing


   Rev 1.102.1.0    23/09/2008 23:10:08  ak
 UK0139.03 updates for CRR COD0013, ready for testing


   Rev 1.102    25/02/2008 16:18:18  jw
 Unused DIFeedbackCode removed


   Rev 1.101    25/01/2008 10:46:42  jw
 VCI3 and Vista functionality files merge - more testing required


   Rev 1.100    18-01-2008 10:44:18  jw
 DR000235 Remove DW support for bitstrings. ConvertToFloat ( inc remove
 redundant input parameter)  and ConverToDouble modified


   Rev 1.99    14/01/2008 21:06:08  ak
 Bug fix: objectNameString and sectionTypeString now populated and used for
 XML serialization (since integer equivalents reference into arrays that are
 built dynamically and subject to change).


   Rev 1.98    05/12/2007 21:13:38  ak
 TC keywords added to source for version control.


*******************************************************************************/
using System;
using System.IO;
using System.Text;
using System.Windows.Forms;
using System.Collections;
using System.Xml.Serialization;
//Jude DR000234 Apply InvariantCulture to all convertsions between strings and floats/doubles/reals
using System.Globalization;


namespace DriveWizard
{
	#region enumerated type definitions

	#region CANopen data types
	/// <summary>
	/// CANopen data types (order and value of each enumerated type is selected to
	/// match CIA specifcation DS301.
	/// This is required by DriveWizard so that it knows how to store and format
	/// each data type for presentation to the user.
	/// </summary>
	[Flags] public enum CANopenDataType 
	{ 
		NULL = 0,
		BOOLEAN = 0x01,
		INTEGER8 = 0x02,
		INTEGER16 = 0x03, 
		INTEGER32 = 0x04,
		UNSIGNED8 = 0x05,
		UNSIGNED16 = 0x06, 
		UNSIGNED32 = 0x07, 
		REAL32 = 0x08,
		VISIBLE_STRING = 0x09,
		OCTET_STRING = 0x0A,
		UNICODE_STRING = 0x0B,
		TIME_OF_DAY = 0x0C,
		TIME_DIFFERENCE = 0x0D,
		RESERVED1 = 0x0E,
		DOMAIN = 0x0F,
		INTEGER24 = 0x10, 
		REAL64 = 0x11,
		INTEGER40 = 0x12,
		INTEGER48 = 0x13,
		INTEGER56 = 0x14,
		INTEGER64 = 0x15,
		UNSIGNED24 = 0x16,
		RESERVED2 = 0x17,
		UNSIGNED40 = 0x18,
		UNSIGNED48 = 0x19,
		UNSIGNED56 = 0x1A,
		UNSIGNED64 = 0x1B,
		RESERVED3 = 0x1C,
		RESERVED4 = 0x1D,
		RESERVED5 = 0x1E,
		RESERVED6 = 0x1F,
		PDO_COMMUNICATION_PARAMETER = 0x20,
		PDO_MAPPING = 0x21,
		SDO_PARAMETER = 0x22,
		IDENTITY = 0x23,
		RECORD = 0x25,
		ARRAY = 0x80 // AND with 0x7F to remove this bit
	};
	#endregion

	#region object access type
	
	/// <summary>
	/// Object Access Type
	/// This is a mix of the CIA specification data access types (ro, wo, rw, rwr, rww, constant)
	/// and DW derived data types used in order to display the data most easily to the user.
	/// For Sevcon nodes, some objects are only writable when the node is in pre-op mode
	/// (otherwise a CANGeneralError is received).  These data types are generated by DW when
	/// the EDS file is read in - the Sevcon EDS file is augmented with a WRITE_IN_PREOP_ONLY
	/// field which is used to derived the new types.
	/// </summary>
	public enum ObjectAccessType 
	{ 
		DWDisplayOnly,					// DW generated object type
		Constant,
		ReadOnly, 
		WriteOnly, 
		ReadWrite, 
		ReadReadWrite, 
		ReadWriteWrite,
		WriteOnlyInPreOp,				// DW generated object type
		ReadWriteInPreOp,				// DW generated object type
		ReadReadWriteInPreOp,			// DW generated object type
		ReadWriteWriteInPreOp,			// DW generated object type
	};
	#endregion
	
	#region EDS object type
	/// <summary>EDS section which a given object resides in</summary>
	public enum CANObjectType
	{
		Mandatory,
		Optional,
		Manufacturer
	};
	#endregion

	#region Sevcon numbering format
	
	/// <summary>
	/// Sevcon controllers have additional fields in the EDS file.  The NUMBER_FORMAT 
	/// is used by DW to determine how best to display the given information for a given
	/// object.  BASE10 is the default data type.  The is displayed in decimal.
	/// BASE16 numbers are displayed in hexadecimal (0x....).  SPECIAL data types have
	/// a number of text strings following it which determine which text string is to 
	/// be displayed for each value (i.e. just like an enumerated data type) e.g. 0=RESET
	/// and 1=SET.
	/// 
	/// These number formats need to be known in advance.
	///	
	/// ADD ANY NEW NUMBER FORMAT TYPES TO THE END OF THIS LIST OTHERWISE DW DOES NOT 
	/// RECOGNISE THE OBJECT.
	///		**** SPELLING MUST BE AN EXACT MATCH TO THE EDS FILE ****
	/// </summary>
	public enum SevconNumberFormat
	{
		BASE10,
		BASE16,
		SPECIAL,
		BIT_SPLIT,

		// ALWAYS KEEP THIS AS THE LAST ENUM
		LAST_SEVCON_FORMAT_TYPE
	};
	#endregion

	/// <summary> CANopen object dictionary sections </summary>
	public enum CANSectionType
	{
		NONE,
		COMMUNICATIONPROFILE,
		MANUFACTURERSPECIFICPROFILE,
		STANDARDISEDDEVICEPROFILE0,
		STANDARDISEDDEVICEPROFILE1,
		STANDARDISEDDEVICEPROFILE2,
		STANDARDISEDDEVICEPROFILE3,
		STANDARDISEDDEVICEPROFILE4,
		STANDARDISEDDEVICEPROFILE5,
		STANDARDISEDDEVICEPROFILE6,
		STANDARDISEDDEVICEPROFILE7
	};

	internal enum defaultValType
	{
		NONE,
		NORMAL,
		NODEID_ADDED,
	}
	#endregion


	#region structure definitions

	#region EDSandDCFFileInfo
		
	/// <summary>
	/// EDSandDCFFileInfo data structure which holds the pertinent file information read in from
	/// the FILEINFO section of the 
	/// </summary>
	public class EDSandDCFFileInfo
	{
		/// <summary> Version of the EDS file being parsed, as a string</summary>
		internal string fileVersion = "";
		
		/// <summary> Revision of the EDS file being parsed, as a string</summary>
		internal string fileRevision = "";
		
		/// <summary> Version of the EDS file being parsed, as a string</summary>
		internal string EDSversion  = "";
		
		/// <summary> Description of what device the EDS is defining the OD for, as a string</summary>
		internal string description = "";

		/// <summary>Time that EDS/DCf file was last changed (currently for DCf same as creation time </summary>
		internal string LastModTime = "";

		/// <summary>Date that EDS/DCf file was last changed (currently for DCf same as creation time </summary>
		internal string LastModDate = "";

		/// <summary>Person/organisation who created the file (used for DCF - displayed by GUI)</summary>
		internal string createdBy = "";
	}
	#endregion

	#region EDSorDCFDeviceInfo
	 	
	/// <summary>
	/// EDSorDCFDeviceInfo data structure which holds the pertinent device information read in from the
	/// DEVICEINFO section of the   These are used to find a matching EDS file to the device
	/// found when reading mandatory object 0x1018 from the controller.
	/// </summary>
	internal class EDSorDCFDeviceInfo
	{
		internal EDSorDCFDeviceInfo()
		{
		}
		/// <summary> string not used for EDS/controller match</summary>
		internal string	vendorName = "";				 

		/// <summary> EDS equivalent of 0x1018 sub 1</summary>
		internal uint		vendorNumber = 0xFFFFFFFF;			
		
		/// <summary> EDS equivalent of 0x1018 sub 2</summary>
		internal uint		productNumber = 0xFFFFFFFF;			
		
		/// <summary> EDS equivalent of 0x1018 sub 3</summary>
		internal uint		revisionNumber = 0xFFFFFFFF;	
		
		/// <summary>string used to describe 3rd party devices (Sevcon has more specific info in productNumber) </summary>
		internal string	productName = "";
		/// <summary>/// string used for oreder code - not yet defined/// </summary>
		internal string orderCode = "";

		internal bool BaudRate_10 = false;
		internal bool BaudRate_20 = false;
		internal bool BaudRate_50 = false;
		internal bool BaudRate_125 = false;
		internal bool BaudRate_250 = false;
		internal bool BaudRate_500 = false;
		internal bool BaudRate_800 = false;
		internal bool BaudRate_1000 = false;
		internal bool SimpleBootUpMaster = false;
		internal bool SimpleBootUpSlave = false;
		internal uint Granularity=64;
		internal bool GroupMessaging=false;
		internal bool DynamicChannelsSupported=false;
		internal uint NrOfRXPDO=0;
		internal uint NrOfTXPDO= 0;
		internal bool LSS_Supported=false;
	}
	#endregion

	#region Comminssioning info
	///<summary>Structure to contain the pertinent commissioning information
	///from the DCF file which is relevant to DriveWizard.
	///</summary>
	public class DCFCommissioningInfo
	{
		/// <summary>node ID of node defined in DCF file </summary>
		public	int			nodeID =0 ;					

		/// <summary>node name of node defined in DCF file</summary>
		public	string		nodeName ="";				
		
		/// <summary>baud rate of node defined in DCF file</summary>
		public	BaudRate	baudRate = BaudRate._unknown;				

		/// <summary>net number of node defined in DCF file</summary>
		public	int			netNumber=0;				

		/// <summary>network name of node defined in DCF file</summary>
		public	string		networkName ="";			

		/// <summary>whether node defined in DCF file is the CAN manager </summary>
		public	bool		CANopenManager = false;		

		/// <summary>LSS serial number of node defined in DCF file</summary>
		public	int			LSS_SerialNumber = 0;		
	}

	#endregion commissioning info

	#region EDSObjectInfo

	/// <summary>
	/// EDSObjectInfo data structure.  Instances of these are used to construct a ragged array
	/// to represent a controller's entire OD.  Each object (or sub-object) requires a certain
	/// amount of information for DW to read/write values to the real controller attached on
	/// the CANbus, and for the correct formatting and display on DW.  All this is held for
	/// each object/sub in an instance of this data structure.
	/// This ragged array is contstructed dynamically when the EDS file is read in.
	/// </summary>
	public class EDSObjectInfo
	{
		public EDSObjectInfo()
		{
		}
		/// <summary> node ID for the controller represented by this instance of the EDSorDCF object.
		/// This is needed to resolve those objects which have a defined default as NODEID + 0x???.</summary>
		[XmlElement("nodeID",typeof(int))]
		public int					nodeID = 0;

		/// <summary> index of object</summary>
		[XmlElement("indexNumber",typeof(int))]
		public int					indexNumber = 0;		

		/// <summary> sub-index of object</summary>
		[XmlElement("subNumber",typeof(int))]
		public int					subNumber = 0;			
		
		/// <summary> text description of what this object is</summary>
		[XmlElement("parameterName",typeof(string))]
		public string				parameterName = "";	
		
		/// <summary>
		/// full descroption of object - Sevcon only
		/// </summary>
		[XmlElement("toolTip",typeof(string))]
		public string toolTip = "";

		/// <summary> data access type (read only, write only etc)</summary>
		[XmlElement("accessType",typeof(ObjectAccessType))]
		public ObjectAccessType		accessType = ObjectAccessType.ReadOnly;			
		
		/// <summary> whether this object can be mapped to a PDO</summary>
		[XmlElement("PDOmappable",typeof(bool))]
		public bool					PDOmappable = false;		
		
		/// <summary> object flags, used for an entire OD scan for uploading and downloading DCFs</summary>
		[XmlElement("objFlags",typeof(byte))]
		public byte					objFlags = 0;			
		
		/// <summary> from EDS combined together objectType to give displayType </summary>
		[XmlElement("dataType",typeof(byte))]
		public byte					dataType = 0;			
		
		/// <summary> from EDS combined together dataType to give displayType</summary>
		[XmlElement("objectType",typeof(byte))]
		public byte					objectType = 7;			

		/// <summary> Sevcon field: scaling to apply to raw values read before displaying to user (eg 5A/bit)</summary>
		[XmlElement("scaling",typeof(float))] 
		public double				scaling = 1F;			 
		
		/// <summary> text string for SI units to display to user</summary>
		[XmlElement("units",typeof(string))] 
		public string				units = "";			
		
		/// <summary> combined dataType and objectType used by DW to determine how to handle particular data type</summary>
		[XmlElement("displayType",typeof(CANopenDataType))] 
		public CANopenDataType		displayType = CANopenDataType.NULL;		

		/// <summary> Sevcon field: access level needed to write to this object (given when user logs on)</summary>
		[XmlElement("accessLevel",typeof(byte))]  
		public byte					accessLevel = 0;		


		/// <summary> used by DVT stored by DW just to write to DCF file as required </summary>
		[XmlElement("object_version",typeof(ushort))] 
		public ushort				object_version = 0;		


		/// <summary> Sevcon field: object belongs into logical sections to help filter and display objects</summary>
        [XmlElement("sectionType", typeof(string))]
        public string sectionTypeString = "NONE";

        /// <summary>Integer equivalent to XML Element sectionTypeString </summary>
		public int	sectionType = (int)SevconSectionType.NONE;		
														
		/// <summary> Sevcon field: used to locate index and sub index so that DW is immune to location changes</summary>
        [XmlElement("objectName", typeof(string))]
        public string objectNameString = "NONE";

        /// <summary>Integer equivalent to XML Element sectionObjectTypeString </summary>
        public int objectName = (int)SevconObjectType.NONE;			
														
		/// <summary> indicates whether this object is a compact object</summary>
		[XmlElement("compactObj",typeof(bool))]  
		public bool					compactObj = false;		
		
		/// <summary> indicates number of compact entries if compactObj is true</summary>
		[XmlElement("compactNoOfEntries",typeof(int))]  
		public int					compactNoOfEntries = 0;	
														
		/// <summary> compact names if compactObj is true</summary>
		[XmlElement("compactNames",typeof(string[]))]  
		public string[]				compactNames = new string[0];	
		
		/// <summary> Sevcon field: number format for data display</summary>
		[XmlElement("format",typeof(SevconNumberFormat))]  
		public SevconNumberFormat	format = SevconNumberFormat.BASE10;				
		
		/// <summary> Sevcon field: delimited text string for SPECIAL format type</summary>
		[XmlElement("formatList",typeof(string))]  
		public string				formatList = "";			
		
		/// <summary> Sevcon field: true if this object can only be written to when the controller in in preop</summary>
		[XmlElement("writeOnlyInPreOp",typeof(bool))]  
		public bool					writeOnlyInPreOp = false;	
														
		/// <summary> communication timeout to be used with transmissions relating to this object</summary>
		[XmlElement("commsTimeout",typeof(int))]  
		public int					commsTimeout = SCCorpStyle.TimeoutDefault;	
	
		/// <summary>EDS section which this object was defined in </summary>
		[XmlElement("EDSObjectType",typeof(CANObjectType))]  
		public CANObjectType		EDSObjectType = CANObjectType.Manufacturer;
				
		/// <summary>If SevconNumberFormat is BIT_SPLIT, this contains details on how to split this 
		/// object into several sub objects (for display on the GUI only) </summary>
		[XmlElement("split",typeof(DataSplit []))]  
		public DataSplit []			split = new DataSplit[0];	
		
		/// <summary>For a select few Sevcon virtual PDO objects, the dummy VPDO is defined.  </summary>
		[XmlElement("dummyVPDO",typeof(int))]  
		public int					dummyVPDO = 0x00;			

		/// <summary> holds the value as a string when read in from the DCF (prior to knowing data type for transformation)</summary>
		[XmlElement("parameterValue",typeof(string[]))]  
		public string[]				parameterValue = new string[0];		
														
		/// <summary> lowest valid value for this object (nos only)</summary>
		[XmlElement("lowLimit",typeof(string))]  
		public string				lowLimit = "";			
		
		/// <summary> highest valid value for this object (nos only)</summary>
		[XmlElement("highLimit",typeof(string))]  
		public string				highLimit = "";			
		
		/// <summary> default value for this object (numbers only)</summary>
		[XmlElement("defaultValue",typeof(string))]  
		public string				defaultValue = "";	
	
		internal defaultValType		defaultType = defaultValType.NONE;
		/// <summary> when true this object is only show for a master Sevcon application node</summary>
		[XmlElement("displayOnMasterOnly",typeof(bool))]  
		public bool					displayOnMasterOnly = false;	
		
		/// <summary> used by DVT stored by DW just to write to DCF file as required </summary>
		[XmlElement("eepromString",typeof(string))]  
		public string eepromString = "";
	}
	#endregion

	#region DataSplit class definition
	/// <summary> DataSplit contains the formatting and display data for one item which is being
	/// split up for display on the GUI.  If an object dictionary item is eg a control word or
	/// a configuration word where different bits or groups of bits within an overall unsigned
	/// integer and it makes more sense to display these separately to the user, a bit split
	/// format is used.  This means that the GUI displays them as separate subs but that
	/// at the CAN communications level it retains the orignal compacted data.
	/// //jude - change to class will allow us to read in EDs in XML format later
	/// </summary>
	public class DataSplit
	{
		public DataSplit()
		{
		}
		public DataSplit(DataSplit olddata)
		{
			this.bitMask = olddata.bitMask;
			this.bitShift = olddata.bitShift;
			this.format = olddata.format;
			this.formatList = olddata.formatList;
			this.highLimit = olddata.highLimit;
			this.lowLimit = olddata.lowLimit;
			this.parameterName = olddata.parameterName;
		}
		/// <summary> number of this split item</summary>
		public int					split = 0;

		/// <summary> text description of what this object is for a split item</summary>
		public string				parameterName = "";
		
		/// <summary> Sevcon field: number format for data display for a split item</summary>
		public SevconNumberFormat	format = SevconNumberFormat.BASE10;
		
		/// <summary>bit mask to be used to extract this split item from overall data </summary>
		public long					bitMask = 0;
		
		/// <summary>bit shifting to be used to extract this split item from overall data </summary>
		public int					bitShift = 0;
		
		/// <summary> text string for SI units to display to user for a split item</summary>
		public string				units = "";

		/// <summary> Sevcon field: delimited text string for SPECIAL format type for a split item</summary>
		public string				formatList = "";			

		/// <summary>contains the low limit for this split item </summary>
		public long					lowLimit = 0;

		/// <summary>contains the high limit for this split item </summary>
		public long					highLimit = 0;
	}
	#endregion

	#region CANSection limits
	/// <summary>
	/// The object dictionary minimum and maximum limits for a given CANopen section.
	/// </summary>
	internal struct CANSectionLimits
	{
		/// <summary>Minimum object dictionary index for objects in this CANopen section </summary>
		internal int minimum;

		/// <summary>Maximum object dictionary index for objects in this CANopen section </summary>
		internal int maximum;

		/// <summary>constructor for the CAN section OD limits</summary>
		/// <param name="min">minimum OD index for objects in this CANopen section</param>
		/// <param name="max">maximum OD index for objects in this CANopen section</param>
		internal CANSectionLimits( int min, int max )
		{
			this.minimum = min;
			this.maximum = max;
		}
	};
	#endregion CANSection limits
	#endregion

	/// <summary>
	/// This class provides the functionality to read a CANopen compliant EDS file 
	/// and extract the object descriptions into the EDSObjectInfo data structure
	///  which is a suitable format for DW to build the replica of the object 
	///  dictionary.
	/// </summary>
	public class EDSorDCF 
	{
		#region variable declarations
	
		SystemInfo sysInfo;


        int[] baudRateAsInts = new int[10]// cannot use (Enum.GetValues(typeof(BaudRate)).GetLength(0)) - since .NEt requires a constant value 
            //enum BaudRate {	_1M, _800K, _500K, _250K, _125K, _50K, _20K, _10K, _100K,_unknown };
                                { 1000, 800, 500, 250, 125, 50, 20, 10, 100, 0 };
        string[] baudRateStrings = new string[10] //use length of baudRates
            //enum BaudRate {    _1M, _800K, _500K, _250K, _125K, _50K, _20K, _10K, _100K, _unknown };
                                { "1000", "800", "500", "250", "125", "50", "20", "10", "100", "unknown" };

		/// <summary>
		/// One instance of the EDS file info class is required to store the pertinent 
		/// information when the EDS file is read in (which matches the controller 
		/// connected on the CANbus).
		/// </summary>
		internal EDSandDCFFileInfo	FileInfo = new EDSandDCFFileInfo();

		/// <summary>
		/// One instance of the device info class is required to store the pertinent 
		/// information when the EDS file is read in.
		/// </summary>
		internal EDSorDCFDeviceInfo	EDSdeviceInfo = new EDSorDCFDeviceInfo();

		internal DCFCommissioningInfo comInfo;

		private nodeInfo assocCANNode = null;

		/// <summary> stream reader to read the EDS file </summary>
		private StreamReader		EDSorDCFsr;

		// underlying file stream used by the stream reader
		private FileStream		EDSorDCFfs;

		/* There were problems rewinding the stream reader/file stream when manipulating
		 * for parsing the EDS.  This was resolved by handling manually hence the current
		 * line which is being read and the actual stream reader position is updated
		 * & maninpulated manually within DW.
		 */
		private long			srPosition = 0;
		private long			srLine = 0;

		#region object lists
		/// <summary> array of strings holding the list of all mandatory objects listed in the EDS file</summary>
		private ArrayList		mandatoryObjectList;
		/// <summary> array of strings holding the list of all optional objects listed in the EDS file</summary>
		private ArrayList 	optionalObjectList;
		/// <summary> array of strings holding the list of all manufacture specific objects listed in the EDS file</summary>
		private ArrayList		manufacturerObjectList;
		#endregion object lists
		/// <summary> node ID for the controller represented by this instance of the EDSorDCF object.
		/// This is needed to resolve those objects which have a defined default as NODEID + 0x???.</summary>
		private int			_nodeID;
		private string			domainFilename;			// filename for log domains
		internal StreamWriter		DCFsw;						// DCF file stream writer
		private FileStream			fsDomain;				// file stream & stream writer for
		private  StreamWriter		swDomain;				// domain file
		#endregion

		#region properties
		#region ignore object flags in the EDS file
		/* Ignore object flags property.  This is set or cleared in a systemInfo object
		 * to determine whether the object flags (read in from the EDS file) have to
		 * be adhered to or ignored.  Only during reading or writing the entire OD
		 * must the obj flags be followed, at all other times they must be ignored.
		 * Only the systemInfo object knowns which operation is being performed so
		 * it must turn this flag on or off as appropriate.
		 */
		private bool		_ignoreObjFlags = true;
		///<summary>Set true when reading or writing the entire OD but set false at all other times.</summary>
		public bool ignoreObjFlags
		{
			get
			{
				return ( _ignoreObjFlags );
			}

			set
			{
				_ignoreObjFlags = value;
			}
		}
		#endregion
		#endregion properties
		
		#region constructor & destructor
		//-------------------------------------------------------------------------
		//  Name			: constructor
		// Description     : This is called when an instance of this class is created.
		//					  The product number, vendor number and revision number
		//					  are initialised to invalid values so that we can tell 
		//					  whether they have been read OK from the EDS file.
		//  Parameters      : None
		//  Used Variables  : EDSdeviceInfo.productNumber - product code
		//					  EDSdeviceInfo.revisionNumber - revision associated with product
		//					  EDSdeviceInfo.vendorNumber - vendor number
		//  Preconditions   : None
		//  Post-conditions : EDSdeviceInfo object has invalid values
		//  Return value    : None
		//--------------------------------------------------------------------------
		///<summary>Creates a new instance of the EDSorDCF class and performs specific initialisation.</summary>
		public EDSorDCF(nodeInfo node, SystemInfo passed_sysInfo)
		{
			// initialise to invalid EDSdeviceInfo values (ensure no erroneous match to a real EDS file).
			EDSdeviceInfo.productNumber = 0xffffffff;
			EDSdeviceInfo.revisionNumber = 0xffffffff;
			EDSdeviceInfo.vendorNumber = 0xffffffff;
			EDSdeviceInfo.productName = "";
			this.assocCANNode = node;
			this.sysInfo = passed_sysInfo;
		}

		//-------------------------------------------------------------------------
		//  Name			: destructor
		//  Description     : Performs any clean-up actions not automatically taken
		//					  care of by .net/C#.
		//					  Currently no requirement for this.
		//  Parameters      : None
		//  Used Variables  : None
		//  Preconditions   : This object is no longer required & is being destructed.
		//  Post-conditions : None
		//  Return value    : None
		//--------------------------------------------------------------------------
		///<summary>Destroys this instance of the EDSorDCF class.</summary>
		~EDSorDCF()
		{
		}

		#endregion

		#region open & closing file
		//-------------------------------------------------------------------------
		//  Name			: open() = > now merged with DCf open
		//  Description     : Opens the EDS file of the filename passed as a parameter
		//					  reading for reading and clears out any previous information
		//					  regarding number of objects & lists, ready to read the EDS
		//					  file in.
		//  Parameters      : filename - Name of EDS filename already found to match the
		//								 given nodeID (matches object 0x1018).
		//					  nodeID - node number of the node this object represents
		//  Used Variables  : EDSdeviceInfo - EDSdeviceInfo structure instance
		//					  fs - file stream
		//					  sr - stream reader
		//					  EDSfilename - property holding matching EDS filename (in case
		//									needed later when writing a DCF)
		//					  noOfObjectsInEDS - total number of objects defined in this EDS
		//					  mandatoryObjectList - list of mandatory objects defined in EDS
		//					  optionalObjectList - list of optional objects defined in EDS
		//					  manufacturerObjectList - list of manufacturer objects in EDS
		//					  srPosition - stream reader position
		//					  srLine - stream reader line position
		//  Preconditions   : filename has already been checked & is known to match the
		//					  controller that this object will represent.
		//  Post-conditions : The filename file has been opened successfully for reading;
		//					  EDSfilename contains filename; structures are cleared out
		//					  reading for reading the detail of the EDS file.
		//  Return value    : fbc - feedback code indicating success or reason of failure
		//  Description     : This file opens the DCF file of the filename passed
		//					  as a parameter and the file is opened with the access
		//					  required, also passed as a parameter.  DCF files
		//					  can be opened for reading (eg for displaying to the
		//					  user then downloading it to another node) or it can
		//					  be opened for writing (ie when saving a node's
		//					  object dictionary's current values to a file).
		//  Parameters      : filename - name of the DCF file to be opened
		//					  access - access required when opening the file
		//							   ie read only, write only, read write, create
		//  Used Variables  : fs - file stream
		//					  DCFsw - stream writer
		//					  sr - stream reader
		//				      requiredFileAccess - file access required for DCF file opened
		//					  domainFilename - constructed DCF filename for the domain file
		//					  fsDomain - file stream for writing the DCF domain file
		//					  swDomain - stream writer for the DCF domain file
		//					  srPosition - current stream reader position in opened DCF file
		//					  DCFfilename - name of the DCF file that is open
		//					  noOfObjectsInEDS - number of objects in the DCF
		//					  mandatoryObjectList - list to hold the mandatory objects
		//								expected to be defined in the opened file
		//					  optionalObjectList - list to hold the optional objects
		//								expected to be defined in the opened file
		//					  manufacturerObjectList - list to hold the manufacturer objects
		//								expected to be defined in the opened file
		//  Preconditions   : The GUI/user has selected a file name of a DCF to be opened
		//					  and the user access determines whether it is to be created
		//					  for writing or opened for reading.
		//  Post-conditions : The DCF file is opened with the required access rights.  If
		//					  it is for writing, then the DCF domain filename equivalent
		//					  is also opened/created, reading for writing.
		//  Return value    : fbc - indicating success or a reason for failure
		//--------------------------------------------------------------------------
		///<summary>Opens the EDS file for reading and clearas out any old information.</summary>
		/// <param name="filename">Name of EDS filename already found to match the given nodeID 
		/// (matches object 0x1018)</param>
		/// <param name="nodeID">node number of the node this object represents</param>
		/// <returns>feedback indicates success or gives a failure reason</returns>
		public DIFeedbackCode open( string filename, FileAccess fileAccess, int nodeID)
		{
			DIFeedbackCode fbc = DIFeedbackCode.DISuccess; 
			srPosition = 0;
			srLine = 0;
			if(filename.ToUpper().IndexOf(".DCF") != -1)
			{
				DCFsw = null;
				fsDomain = null;
				swDomain = null;
				domainFilename = filename.Substring(0, filename.LastIndexOf(".")) + ".dmn";
			}
			// save nodeID to the private copy for this object
			_nodeID = nodeID;
			#region try and open relevent stream writers and readers
			try
			{
				switch ( fileAccess )
				{
					case FileAccess.Write:
						#region open file stream writer
						EDSorDCFfs = new FileStream( filename, System.IO.FileMode.Create, fileAccess,FileShare.Read );
						DCFsw = new StreamWriter( EDSorDCFfs );
						fbc = DIFeedbackCode.DISuccess;
						#endregion
						#region open domain file stream writer
						fsDomain = new FileStream( domainFilename, System.IO.FileMode.Create, fileAccess, FileShare.Read );
						swDomain = new StreamWriter( fsDomain );
						#endregion
						break;

					case FileAccess.ReadWrite:
						#region open file stream writer and reader
						EDSorDCFfs = new FileStream( filename, System.IO.FileMode.Create, fileAccess, FileShare.Read );
						DCFsw = new StreamWriter( EDSorDCFfs );
						EDSorDCFsr = new StreamReader( EDSorDCFfs );
						#endregion
						#region open domain file stream writer
						fsDomain = new FileStream( domainFilename, System.IO.FileMode.Create, fileAccess,FileShare.Read );
						swDomain = new StreamWriter( fsDomain );
						#endregion
						break;

					case FileAccess.Read:
					default:
						#region read only access
						EDSorDCFfs = new FileStream( filename, System.IO.FileMode.Open, fileAccess);
						EDSorDCFsr = new StreamReader( EDSorDCFfs );
						#endregion read only access
						break;
				}
			}
			catch ( Exception e )
			{
				#region reset filenames and inform user of error
				domainFilename = "";
				fbc = DIFeedbackCode.DIFailedToOpenEDSorDCFFile;
				SystemInfo.errorSB.Append("Could not open file: filename \nException: " + e.Message);
				#endregion reset filenames and inform user of error
			}
			#endregion try and open relevent stream writers and readers
			return ( fbc );
		}

		//-------------------------------------------------------------------------
		//  Name			: close()
		//  Description     : Closes the EDS/DCF file previously opened and clears out
		//					  variables ready for reading the next file.
		//  Parameters      : None
		//  Used Variables  : fs - file stream
		//					  sr - stream reader
		//					  EDSfilename - property holding matching EDS filename (in case
		//									needed later when writing a DCF)
		//					  noOfObjectsInEDS - total number of objects defined in this EDS
		//					  mandatoryObjectList - list of mandatory objects defined in EDS
		//					  optionalObjectList - list of optional objects defined in EDS
		//					  manufacturerObjectList - list of manufacturer objects in EDS
		//					  srPosition - stream reader position
		//					  srLine - stream reader line position
		//  Preconditions   : The EDS file has already been opened and the EDS file has been
		//					  read or had a failure reason & now requires to be closed.
		//  Post-conditions : EDS file is closed and relevant variables cleared out
		//					  ready for reading the next file.
		//  Return value    : fbc - feedback code indicating success or reason of failure
		//--------------------------------------------------------------------------
		///<summary>Closes the previously opened EDS and DCF file.</summary>
		public void closeEDSorDCF()
		{
			domainFilename = "";
			mandatoryObjectList = null;
			optionalObjectList = null;
			manufacturerObjectList = null;

			if(DCFsw != null)
			{
				DCFsw.Flush();
				DCFsw.Close();
			}
			if ( EDSorDCFsr != null )
			{
				EDSorDCFsr.Close();
			}
			if ( EDSorDCFfs != null )
			{
				EDSorDCFfs.Close();  
			}
			#region close the domain file stream writer (if it was opened)
			if ( swDomain != null )
			{
				swDomain.Close();
			}
			#endregion

			#region close the domain file stream (if it was opened)
			if ( fsDomain != null )
			{
				fsDomain.Close();
			}
			#endregion
		}
		#endregion

		#region reading of EDSdeviceInfo, DeviceInfo and all object description sections
		//-------------------------------------------------------------------------
		//  Name			: readEDSFileInfoSection()
		//  Description     : Finds the FileInfo section in the opened EDS file then
		//					  reads the pertinent information from this section and
		//					  stores in the FileInfo object.
		//  Parameters      : None
		//  Used Variables  : EDSdeviceInfo - object used to store relevant data read in
		//								 from the EDS
		//  Preconditions   : EDS file matching the attached device has been found
		//					  and opened successfully for reading.
		//  Post-conditions : EDSdeviceInfo structure filled with relevant data found
		//					  in the EDS file that is already opened.
		//  Return value    : fbc - feedback code indicating success or reason of failure
		//--------------------------------------------------------------------------
		///<summary>Finds the FileInfo section in the EDS file and extracts the relevant information.</summary>
		/// <returns>feedback indicates success or gives a failure reason</returns>
		public DIFeedbackCode readFileInfoSection(string filepath, out EDSandDCFFileInfo fileInfo)
		{
			fileInfo = new EDSandDCFFileInfo();
			DIFeedbackCode fbc = DIFeedbackCode.DIFailedToReadFileInformationSectionInEDS;
			string input;				// current line of the EDS file read in
			string upperCaseInput;		// input converted to upper case text
			bool sectionEnd = false;	// end of section found flag

			// Cannot assume order of sections in EDS so rewind back to start of file.
			rewind(filepath, FileAccess.Read);
			// Find the FileInfo section in the EDS.
			while ( ( input = readLine() ) != null )
			{
				removePartLineComments( input );
				// convert to upper case so file reading is case insensitive.
				upperCaseInput = input.ToUpper();

				// If this line is the start of the FILEINFO section then read the section in.
				if ( ( upperCaseInput.IndexOf( "[FILEINFO]" ) != -1 ) && ( aComment( upperCaseInput) == false ) )
				{
					// found the fileinfo section so set feedback code to success.
					fbc = DIFeedbackCode.DISuccess;

					/* While not the end of the file (and the end of this section hasn't been found)
						 * then check each line to see if it contains the information we require.
						 */
					while ( ( input = readLine() ) != null )
					{
						// convert to uppercase & remove comments to make more robust a reader
						string valueSubString = this.getvalueSubString(input);
//						removePartLineComments( input );
						upperCaseInput = input.ToUpper();

						// If found the start of another section so quit this loop.
						if ( endOfSection( input) == true )
						{
							break;
						}
							#region extract fileinfo date from correct filelines
							// If this line is a comment then ignore it.
						else if ( aComment( upperCaseInput) == true )
						{
						}
						else if ( upperCaseInput.IndexOf( "FILEVERSION" ) != -1 )
						{
							fileInfo.fileVersion = valueSubString;  
						}
						else if ( upperCaseInput.IndexOf( "FILEREVISION" ) != -1 )
						{
							fileInfo.fileRevision = valueSubString;
						}
						else if ( upperCaseInput.IndexOf( "EDSVERSION" ) != -1 )
						{
							fileInfo.EDSversion = valueSubString;
						}
						else if ( upperCaseInput.IndexOf( "DESCRIPTION" ) != -1 )
						{
							fileInfo.description = valueSubString;
						}
						else if (upperCaseInput.IndexOf("MODIFICATIONTIME") != -1)
						{
							fileInfo.LastModTime = valueSubString;
						}
						else if(upperCaseInput.IndexOf("MODIFICATIONDATE") != -1)
						{
							fileInfo.LastModDate  = valueSubString;
						}
						else if (upperCaseInput.IndexOf("CREATEDBY") != -1)
						{
							fileInfo.createdBy = valueSubString;
						}
						#endregion extract fileinfo date from correct filelines
					} // end of inner while loop					
				
					// If found the start of another section so quit this loop.
					if ( sectionEnd )
					{
						break;
					}
				} // end of if found section loop
			} // end of outer while loop

            //DR38000260 - additional error feedback for incorrect EDS/DCF file format
			if ((fbc != DIFeedbackCode.DISuccess) && (MAIN_WINDOW.appendErrorInfo == true))
			{
				SystemInfo.errorSB.Append("\nFormat error in [FileInformation] section " + filepath);
			}
			return ( fbc );
		}


		//-------------------------------------------------------------------------
		//  Name			: readDeviceInfo()
		//  Description     : Finds the DEVICEINFO section in the opened EDS file
		//					  and extracts the relevant information for DW and saves
		//					  into the EDSdeviceInfo object.
		//  Parameters      : None
		//  Used Variables  : EDSdeviceInfo - structure with vendorID, product number
		//								   and revision number and vendor name.
		//  Preconditions   : Matching EDS file for this device has been found and
		//					  opened ready for reading.
		//  Post-conditions : EDSdeviceInfo structure has been populated with pertinent
		//					  infomation required by DW.
		//  Return value    : fbc - feedback code indicating success or reason of failure
		//--------------------------------------------------------------------------
		///<summary>Finds the DeviceInfo section in the EDS file and extracts the relevant information.</summary>
		/// <returns>feedback indicates success or gives a failure reason</returns>
		public DIFeedbackCode readDeviceInfo(string filepath, out uint vendorID, out uint productCode, out uint revNo)
		{
			string input;
			string upperCaseInput;
			bool sectionEnd = false;
			DIFeedbackCode fbc;
			vendorID = 0xFFFFFFF;
			productCode = 0xffffffff;
			revNo = 0xffffffff;

			string EDStest = filepath.ToUpper();
			fbc = DIFeedbackCode.DIFailedToReadDeviceInformationSectionInEDS;
			#region get and store [DeviceInfo] section information
			// Rewind to start of file as can't assume section order in EDS orDCF
			rewind(filepath, FileAccess.Read );

			// Find the Device Info section in the EDS file & read pertinent info.
			while ( ( input = readLine() ) != null )
			{
				// case insensitive so convert to upper case and remove comments on the line
				removePartLineComments( input );
				upperCaseInput = input.ToUpper();

				// If found the start of the device info section, then read the pertinent info.
				if ( ( upperCaseInput.IndexOf( "[DEVICEINFO]" ) != -1 ) && ( aComment( upperCaseInput ) == false ) )
				{
					// Found the section so assume read it OK.
					fbc = DIFeedbackCode.DISuccess;

					/* While not the end of the file (and the end of this section hasn't been found)
										 * then check each line to see if it contains the information we require.
										 */
					while ( ( input = readLine() ) != null )
					{

//						removePartLineComments( input );
						upperCaseInput = input.ToUpper();
						string valueSubString = getvalueSubString(input);
						// Quit this loop if found the end of this section.
						if ( endOfSection( input) ==true )
						{
							break;
						}
							// Else ignore any comments.
						else if ( aComment( upperCaseInput ) == true )
						{
						}
						else if ( upperCaseInput.IndexOf( "VENDORNAME" ) != -1 )
						{
							EDSdeviceInfo.vendorName = valueSubString;
						}
						else if ( upperCaseInput.IndexOf( "VENDORNUMBER" ) != -1 )
						{
							EDSdeviceInfo.vendorNumber = sysInfo.convertToUint(valueSubString);
							vendorID =EDSdeviceInfo.vendorNumber;
						}
						else if ( upperCaseInput.IndexOf( "PRODUCTNUMBER" ) != -1 )
						{
							EDSdeviceInfo.productNumber = sysInfo.convertToUint(valueSubString);
							productCode = EDSdeviceInfo.productNumber;
						}
						else if ( upperCaseInput.IndexOf( "REVISIONNUMBER" ) != -1 )
						{
							EDSdeviceInfo.revisionNumber = sysInfo.convertToUint(valueSubString);
							revNo = EDSdeviceInfo.revisionNumber;
						}
						else if ( upperCaseInput.IndexOf( "PRODUCTNAME" ) != -1 )
						{
							EDSdeviceInfo.productName = valueSubString;
						}
						else if(upperCaseInput.IndexOf("ORDERCODE") != -1)
						{
							EDSdeviceInfo.orderCode = valueSubString;
						}
						else if (upperCaseInput.IndexOf("BAUDRATE_500") != -1)
						{  //put before BAUDRATE_50 - other wise we drop into BAUDRATE_50 
							EDSdeviceInfo.BaudRate_500 = sysInfo.convertToBool(valueSubString);
							if(sysInfo.conversionOK == false)
							{
								SystemInfo.errorSB.Append("Failed to convert ");
								SystemInfo.errorSB.Append(input);
								SystemInfo.errorSB.Append(" to boolean value. Defaulting to 500k baud rate not implemented");
							}
						}
						else if (upperCaseInput.IndexOf("BAUDRATE_1000") != -1)
						{	//put before BAUDRATE_10 - other wise we drop into BAUDRATE_10 
							EDSdeviceInfo.BaudRate_1000 = sysInfo.convertToBool(valueSubString);
							if(sysInfo.conversionOK == false)
							{
								SystemInfo.errorSB.Append("Failed to convert ");
								SystemInfo.errorSB.Append(input);
								SystemInfo.errorSB.Append(" to boolean value. Defaulting to 1M baud rate not implemented");
							}
						}
						else if (upperCaseInput.IndexOf("BAUDRATE_10") != -1)
						{
							EDSdeviceInfo.BaudRate_10 = sysInfo.convertToBool(valueSubString);
							if(sysInfo.conversionOK == false)
							{
								SystemInfo.errorSB.Append("Failed to convert ");
								SystemInfo.errorSB.Append(input);
								SystemInfo.errorSB.Append(" to boolean value. Defaulting to 10k baud rate not implemented");
							}
						}
						else if (upperCaseInput.IndexOf("BAUDRATE_20") != -1)
						{
							EDSdeviceInfo.BaudRate_20 = sysInfo.convertToBool(valueSubString);
							if(sysInfo.conversionOK == false)
							{
								SystemInfo.errorSB.Append("Failed to convert ");
								SystemInfo.errorSB.Append(input);
								SystemInfo.errorSB.Append(" to boolean value. Defaulting to 20k baud rate not implemented");
							}
						}
						else if (upperCaseInput.IndexOf("BAUDRATE_50") != -1)
						{
							EDSdeviceInfo.BaudRate_50 =  sysInfo.convertToBool(valueSubString);
							if(sysInfo.conversionOK == false)
							{
								SystemInfo.errorSB.Append("Failed to convert ");
								SystemInfo.errorSB.Append(input);
								SystemInfo.errorSB.Append(" to boolean value. Defaulting to 50k baud rate not implemented");
							}
						}
						else if (upperCaseInput.IndexOf("BAUDRATE_125") != -1)
						{
							EDSdeviceInfo.BaudRate_125 =  sysInfo.convertToBool(valueSubString);
							if(sysInfo.conversionOK == false)
							{
								SystemInfo.errorSB.Append("Failed to convert ");
								SystemInfo.errorSB.Append(input);
								SystemInfo.errorSB.Append(" to boolean value. Defaulting to 125k baud rate not implemented");
							}
						}
						else if (upperCaseInput.IndexOf("BAUDRATE_250") != -1)
						{
							EDSdeviceInfo.BaudRate_250 = sysInfo.convertToBool(valueSubString);
							if(sysInfo.conversionOK == false)
							{
								SystemInfo.errorSB.Append("Failed to convert ");
								SystemInfo.errorSB.Append(input);
								SystemInfo.errorSB.Append(" to boolean value. Defaulting to 250k baud rate not implemented");
							}
						}
						else if (upperCaseInput.IndexOf("BAUDRATE_800") != -1)
						{
							EDSdeviceInfo.BaudRate_800 = sysInfo.convertToBool(valueSubString);
							if(sysInfo.conversionOK == false)
							{
								SystemInfo.errorSB.Append("Failed to convert ");
								SystemInfo.errorSB.Append(input);
								SystemInfo.errorSB.Append(" to boolean value. Defaulting to 800k baud rate not implemented");
							}
						}
						else if(upperCaseInput.IndexOf("SIMPLEBOOTUPMASTER") != -1)
						{
							EDSdeviceInfo.SimpleBootUpMaster = sysInfo.convertToBool(valueSubString);
							if(sysInfo.conversionOK == false)
							{
								SystemInfo.errorSB.Append("Failed to convert ");
								SystemInfo.errorSB.Append(input);
								SystemInfo.errorSB.Append(" to boolean value. Defaulting to SIMPLEBOOTUPMASTER false");
							}
						}
						else if(upperCaseInput.IndexOf("SIMPLEBOOTUPSLAVE") != -1)
						{
							EDSdeviceInfo.SimpleBootUpSlave = sysInfo.convertToBool(valueSubString);
							if(sysInfo.conversionOK == false)
							{
								SystemInfo.errorSB.Append("Failed to convert ");
								SystemInfo.errorSB.Append(input);
								SystemInfo.errorSB.Append(" to boolean value. Defaulting to SIMPLEBOOTUPSLAVE false");
							}
						}
						else if(upperCaseInput.IndexOf("GRANULARITY") != -1)
						{
							EDSdeviceInfo.Granularity = sysInfo.convertToUint(valueSubString);
							if(sysInfo.conversionOK == false)
							{
								SystemInfo.errorSB.Append("Failed to convert ");
								SystemInfo.errorSB.Append(input);
								SystemInfo.errorSB.Append(" to boolean value. Defaulting to GRANULARITY false");
							}
						}
						else if(upperCaseInput.IndexOf("GROUPMESSAGEING") != -1)
						{
							EDSdeviceInfo.GroupMessaging =  sysInfo.convertToBool(valueSubString);
							if(sysInfo.conversionOK == false)
							{
								SystemInfo.errorSB.Append("Failed to convert ");
								SystemInfo.errorSB.Append(input);
								SystemInfo.errorSB.Append(" to boolean value. Defaulting to GROUPMESSAGEING false");
							}
						}
						else if(upperCaseInput.IndexOf("DYNAMICCHANNELISSUPPORTED") != -1)
						{
							EDSdeviceInfo.DynamicChannelsSupported = sysInfo.convertToBool(valueSubString);
							if(sysInfo.conversionOK == false)
							{
								SystemInfo.errorSB.Append("Failed to convert ");
								SystemInfo.errorSB.Append(input);
								SystemInfo.errorSB.Append(" to boolean value. Defaulting to DYNAMICCHANNELISSUPPORTED false");
							}
						}
						else if(upperCaseInput.IndexOf("NROFRXPDO") != -1)
						{
							EDSdeviceInfo.NrOfRXPDO = sysInfo.convertToUint(valueSubString);
						}
						else if(upperCaseInput.IndexOf("NROFTXPDO") != -1)
						{
							EDSdeviceInfo.NrOfTXPDO = sysInfo.convertToUint(valueSubString);
						}
						else if(upperCaseInput.IndexOf("LSS_SUPPORTED") != -1)
						{
							EDSdeviceInfo.LSS_Supported = sysInfo.convertToBool(valueSubString);
							if(sysInfo.conversionOK == false)
							{
								SystemInfo.errorSB.Append("Failed to convert ");
								SystemInfo.errorSB.Append(input);
								SystemInfo.errorSB.Append(" to boolean value. Defaulting to LSS not supported");
							}
						}
					} // end of inner while loop

					// If found the start of another section so quit this loop.
					if ( sectionEnd )
					{
						break;
					}
				} // end of if section found
			} // end of outer while loop
			if ( fbc != DIFeedbackCode.DISuccess )
			{
				SystemInfo.errorSB.Append("[DEVICEINFO] section missing in ");
				SystemInfo.errorSB.Append(filepath);
			}
			#endregion  get and store [DeviceInfo] section information

            //DR38000260 - additional error feedback
            if ((fbc != DIFeedbackCode.DISuccess) && (MAIN_WINDOW.appendErrorInfo == true))
            {
                SystemInfo.errorSB.Append("\nFormat error in [DeviceInfo] section.");
            }
            return ( fbc );
		}
		//-------------------------------------------------------------------------
		//  Name			: readNoOfObjectsInEDS()
		//  Description     : Scans the opened EDS file to determine how many mandatory, optional
		//					  and manufacturer objects are defined in the file.  These are then
		//					  summed to determine the total number of objects defined.
		//  Parameters      : None
		//	Used Variables  : noOfObjectsInEDS - total number of objects defined in this EDS
		//					  mandatoryObjectList - list of mandatory objects defined in EDS
		//					  optionalObjectList - list of optional objects defined in EDS
		//					  manufacturerObjectList - list of manufacturer objects in EDS
		//					  noOfMandatoryObjects - number of mandatory objects defined in EDS
		//				      noOfOptionalObjects - number of optional objects defined in EDS
		//					  noOfManufacturerObjects - number of manufacturer objects in EDS
		//  Preconditions   : Matching EDS file for this device has been found and
		//					  opened ready for reading.
		//  Post-conditions : All of the used variables above are populated.
		//  Return value    : fbc - feedback code indicating success or reason of failure
		//--------------------------------------------------------------------------
		///<summary>Scans the opened EDS file to ascertain how many objects are defined within the file.</summary>
		/// <returns>feedback indicates success or gives a failure reason</returns>
		public DIFeedbackCode readNoOfObjects(string filepath)
		{
			#region local variable declarations and variable initialisation
			DIFeedbackCode fbc;
			string input;
			string upperCaseInput;
			#endregion
			
			mandatoryObjectList = new ArrayList();
			mandatoryObjectList = new ArrayList();
			optionalObjectList = new ArrayList();
			optionalObjectList = new ArrayList();
			manufacturerObjectList = new ArrayList();
			manufacturerObjectList = new ArrayList();

			bool mandatorySectFound = false, optSectFpund = false, manfSectFound = false;
			string EDStest = filepath.ToUpper();
			if(EDStest.IndexOf(".EDS") != -1)
			{
				fbc = DIFeedbackCode.DIFailedToReadObjectListsInEDS;
				#region EDS
				// Can't assume the order of sections in the EDS so rewind to start of the file.
				rewind(filepath, FileAccess.Read);

				// Read the EDS file until end of file is found or we've found all 3 sections.
				while ( ( input = readLine() ) != null )
				{
					/* Make case insensitive and remove any comments from the line 
								 * (avoid reading irrelevant data). */
					removePartLineComments( input );
					upperCaseInput = input.ToUpper();
					
					if (( mandatorySectFound == true) &&  (optSectFpund == true) && (manfSectFound == true))
					{// If found the required three sections then quit this loop.
						break;
					}
						// Else ignore comments (as could contain correctly formatted out of date info).
					else if ( aComment( upperCaseInput ) == true )
					{					
					}
						/* If found the mandatory objects section then read the list of objects expected
									 * to follow (so can cross check later) and increment sections found.
									 */
					else if ( upperCaseInput.IndexOf( "[MANDATORYOBJECTS]" ) != -1 )
					{
						mandatorySectFound = true;
						fbc = readObjectList( filepath,mandatoryObjectList );

                        if (fbc != DIFeedbackCode.DISuccess) //DR38000260
                        {
                            SystemInfo.errorSB.Append("\nCheck the SupportedObjects list for the [MANDATORYOBJECTS] section of file " + filepath.ToString());
                            SystemInfo.errorSB.Append("\nObjects may be missing from this node's displayed tree view.");
                        }
					}
						/* If found the optional objects section then read the list of objects expected
									 * to follow (so can cross check later) and increment sections found.
									 */
					else if ( upperCaseInput.IndexOf( "[OPTIONALOBJECTS]" ) != -1 )
					{
						optSectFpund = true;
						fbc = readObjectList(filepath,  optionalObjectList );

                        if (fbc != DIFeedbackCode.DISuccess) //DR38000260
                        {
                            SystemInfo.errorSB.Append("\nCheck the SupportedObjects list for the [OPTIONALOBJECTS] section of file " + filepath.ToString());
                            SystemInfo.errorSB.Append("\nObjects may be missing from this node's displayed tree view.");
                        }
                    }
						/* If found the manufacturer specific objects section then read the list of 
									 * objects expected to follow (so can cross check later) and increment sections 
									 * found.
									 */
					else if ( upperCaseInput.IndexOf( "[MANUFACTUREROBJECTS]" ) != -1 )
					{
						manfSectFound = true;
						fbc = readObjectList(filepath, manufacturerObjectList );

                        if (fbc != DIFeedbackCode.DISuccess) //DR38000260
                        {
                            SystemInfo.errorSB.Append("\nCheck the SupportedObjects list for the [MANUFACTUREROBJECTS] section of file " + filepath.ToString());
                            SystemInfo.errorSB.Append("\nObjects may be missing from this node's displayed tree view.");
                        }
                    }
				}
				// If found all sections then set feedback code to reflect a success.
				if (( mandatorySectFound == true) &&  (optSectFpund == true) && (manfSectFound == true))
				{
					fbc = DIFeedbackCode.DISuccess;
				}
					#region user feedback
				else
				{
					if (mandatorySectFound == false )
					{
						SystemInfo.errorSB.Append("\n[MANDATORYOBJECTS] section missing in ");
						SystemInfo.errorSB.Append(filepath);
					}
					if ( optSectFpund == false )
					{
						SystemInfo.errorSB.Append("\n[OPTIONALOBJECTS] section missing in ");
						SystemInfo.errorSB.Append(filepath);
					}
					if ( manfSectFound == false )
					{
						SystemInfo.errorSB.Append("\n[MANUFACTUREROBJECTS] section missing in ");
						SystemInfo.errorSB.Append(filepath);
					}
				}
				#endregion  user feedback
				#endregion EDS
			}
			else if ( EDStest.IndexOf(".DCF") != -1)
			{
				fbc = DIFeedbackCode.DIFailedToReadObjectListsInDCF;
				#region DCF
				// Can't assume the order of sections in the EDS so rewind to start of the file.
				rewind(filepath, FileAccess.Read);	

				// Read the EDS file until end of file is found or we've found all 3 sections.
				while ( ( input = readLine() ) != null )
				{
					/* Make case insensitive and remove any comments from the line 
								 * (avoid reading irrelevant data).
								 */
					removePartLineComments( input );
					upperCaseInput = input.ToUpper();

					// If found the required three sections then quit this loop.
					if (( mandatorySectFound == true) &&  (optSectFpund == true) && (manfSectFound == true))
					{
						break;
					}
						// Else ignore comments (as could contain correctly formatted out of date info).
					else if ( aComment( upperCaseInput ) == true )
					{					
					}
						/* If found the mandatory objects section then read the list of objects expected
									 * to follow (so can cross check later) and increment sections found.
									 */
					else if ( upperCaseInput.IndexOf( "[MANDATORYOBJECTS]" ) != -1 )
					{
						mandatorySectFound = true;
						readObjectList( filepath, mandatoryObjectList );
					}
						/* If found the optional objects section then read the list of objects expected
									 * to follow (so can cross check later) and increment sections found.
									 */
					else if ( upperCaseInput.IndexOf( "[OPTIONALOBJECTS]" ) != -1 )
					{
						optSectFpund = true;
						readObjectList( filepath, optionalObjectList );
					}
						/* If found the manufacturer specific objects section then read the list of 
									 * objects expected to follow (so can cross check later) and increment sections 
									 * found.
									 */
					else if ( upperCaseInput.IndexOf( "[MANUFACTUREROBJECTS]" ) != -1 )
					{
						manfSectFound = true;
						readObjectList( filepath, manufacturerObjectList );
					}
				}
				// If found all sections then set feedback code to reflect a success.
				if (( mandatorySectFound == true) &&  (optSectFpund == true) && (manfSectFound == true))
				{
					fbc = DIFeedbackCode.DISuccess;
				}
				else
				{
					#region user feedback
					if ( mandatorySectFound== false)
					{
						SystemInfo.errorSB.Append("Missing [MANDATORYOBJECTS] section in file ");
						SystemInfo.errorSB.Append(this.assocCANNode.EDSorDCFfilepath);
					}
					if ( optSectFpund == false)
					{
						SystemInfo.errorSB.Append("Missing [OPTIONALOBJECTS section in file ");
						SystemInfo.errorSB.Append(this.assocCANNode.EDSorDCFfilepath);
					}
				
					if (manfSectFound == false )
					{
						SystemInfo.errorSB.Append("Missing [MANUFACTUREROBJECTS] section in file ");
						SystemInfo.errorSB.Append(this.assocCANNode.EDSorDCFfilepath);
					}
					#endregion user feedback
				}
				#endregion DCF
			}
			else
			{
				fbc = DIFeedbackCode.DIInvalidFilename;
			}

            //DR38000260 - additional error feedback
            if ((fbc != DIFeedbackCode.DISuccess) && (MAIN_WINDOW.appendErrorInfo == true))
            {
                SystemInfo.errorSB.Append("\nFormat error in SupportedObjects section.");

                if (mandatorySectFound == false)
                { 
                    SystemInfo.errorSB.Append("\nFormat error in [MandatoryObjects] section.");
                }
                
                if (optSectFpund == false)
                { 
                    SystemInfo.errorSB.Append("\nFormat error in [OptionalObjects] section.");
                }
                
                if (manfSectFound == false)
                { 
                    SystemInfo.errorSB.Append("\nFormat error in [ManufacturerObjects] section.");
                }
            }

			return ( fbc );
		}
		//-------------------------------------------------------------------------
		//  Name			: readAllObjectDescriptions()
		//  Description     : This function creates the DW's replica copy of the object
		//					  dictionary by allocating the memory (noOfObjectsInEDS).
		//					  It then reads the definition of each mandatory object
		//					  from the EDS as listed in the mandatoryObjectList.
		//					  It then repeats for the optional & manufacturer specific
		//					  objects.  This provides cross-checking of the EDS file that
		//					  all expected objects are found.
		//  Parameters      : od - object dictionary which is to be constructed and 
		//						   populated with all object information read from EDS
		//	Used Variables  : noOfObjectsInEDS - total number of objects defined in this EDS
		//					  mandatoryObjectList - list of mandatory objects defined in EDS
		//					  optionalObjectList - list of optional objects defined in EDS
		//					  manufacturerObjectList - list of manufacturer objects in EDS
		//  Preconditions   : Matching EDS file for this device has been found and
		//					  opened ready for reading plus we have already read in the
		//					  expected number of objects in EDS and have a list of all the
		//					  indices of them.
		//  Post-conditions : od is created and populated with all the relevant information
		//					  read from the EDS for all the objects in the mandatory, optional
		//					  and manufacturer specific lists.
		//  Return value    : fbc - feedback code indicating success or reason of failure
		//--------------------------------------------------------------------------
		///<summary>Creates DW's replica object dictionary by reading all the EDS object definitions.</summary>
		/// <param name="od">object dictionary which is to be constructed and populated with all 
		/// object information read from EDS</param>
		/// <returns>feedback indicates success or gives a failure reason</returns>
		public DIFeedbackCode readAllObjectDescriptions(string filepath,  nodeInfo CANnode )
		{
			DIFeedbackCode fbc = DIFeedbackCode.DISuccess;
			DIFeedbackCode firstFail = DIFeedbackCode.DISuccess;
			// Create the object dictionary of the size required.
			CANnode.objectDictionary = new ArrayList();
			// Read all the mandatory object definitions from file and copy in the object dictionary.
			firstFail = readObjectDescriptions( filepath, mandatoryObjectList, CANObjectType.Mandatory, CANnode );
			// Read all the optional object definitions from file and copy in the object dictionary.
			fbc = readObjectDescriptions(filepath, optionalObjectList, CANObjectType.Optional, CANnode );
			if(firstFail == DIFeedbackCode.DISuccess) 
			{
				firstFail = fbc;
			}
			// Read all the manufacturer specific object definitions from file and copy in the object dictionary.
			fbc = readObjectDescriptions( filepath,manufacturerObjectList, CANObjectType.Manufacturer, CANnode );			
			if(firstFail == DIFeedbackCode.DISuccess) 
			{
				firstFail = fbc;
			}

            //DR38000260 - additional error feedback
            if ((firstFail != DIFeedbackCode.DISuccess) && (MAIN_WINDOW.appendErrorInfo == true))
            {
                SystemInfo.errorSB.Append("\nFormat error in object desciptions section: " + firstFail.ToString());
            }
			return ( firstFail );
		}
		#endregion

		#region internal functions
		//-------------------------------------------------------------------------
		//  Name			: readObjectDescription()
		//  Description     : This function reads in one object definition (objectIdentifier)
		//					  and populates the tempData EDS object info structure with the
		//					  valid that read from the EDS file.  Defaults are assumed and
		//					  only replaced when the EDS indicates otherwise.
		//  Parameters      : objectIdentifier - text string equivalent of the index of
		//							the object to be read in from the EDS eg [1000]
		//					  tempData - object which is to be populated with the 
		//							information that is read in from this section of the EDS.
		//  Used Variables  : None
		//  Preconditions   : Matching EDS file for this device has been found and
		//					  opened ready for reading. The object lists have been read
		//					  and one object has been passed as a parameter which is the
		//					  required object to be found and read from the file.
		//  Post-conditions : tempData is populated with the EDS defined data for the
		//					  objectIdentifier object.
		//  Return value    : fbc - feedback code indicating success or reason of failure
		//--------------------------------------------------------------------------
		///<summary>Reads a single object definition (of index objectIdentifier)from the opened EDS file and places relevant data into tempData.</summary>
		/// <param name="objectIdentifier">text string equivalent of the index of the object to be read in from the EDS eg [1000]</param>
		/// <param name="tempData">object which is to be populated with the information that is read in from 
		/// this section of the EDS</param>
		/// <returns>feedback indicates success or gives a failure reason</returns>
		internal DIFeedbackCode readObjectDescription( string filepath, string objectIdentifier, EDSObjectInfo tempData )
		{
			#region local variable declarations and variable initialisation
			DIFeedbackCode fbc = DIFeedbackCode.DIFailedToReadObjectDescriptionInEDS;
			string input;
			string upperCaseInput;
			#endregion
			#region comments
			/* Read the EDS file one line at a time until we've read the entire definition
							 * of the objectIdentifier of interest or we've reached the end of the file.
							 */
			#endregion comments
			while ( ( input = readLine() ) != null )
			{	
				string valueSubString = getvalueSubString(input);
				upperCaseInput = input.ToUpper(); //make case insensitive
				#region comments
				/* If found the object identifier required (text string e.g. [1000... and it is
									 * not commented out then read the object definition to populate tempData.
									 */
				#endregion comments
				if ( ( upperCaseInput.IndexOf( objectIdentifier ) != -1 ) && ( aComment( upperCaseInput) == false ) )
				{
					#region Found OD item we're looking for
					#region if entry for sub then  get the sub number
					if ( upperCaseInput.IndexOf( "SUB" ) != -1 )
					{
						string subIndexValueSubString = upperCaseInput.Substring(upperCaseInput.IndexOf( "SUB" ) +3);
						subIndexValueSubString =  "0X" + subIndexValueSubString.Replace("]", ""); //it is on hex so add the 0x so the the converison method knows
						tempData.subNumber = (int)sysInfo.convertToUint(subIndexValueSubString);
					}
					#endregion if entry for sub then  get the sub number
					#region comments
					/* Read in this object definition section one line at a time, extracting 
											 * the information required and converting it from text string to the 
											 * relevant data type.
											 */
					#endregion comments
					while (1<2)
					{
						input = readLine();
						if(input == null) //End Of File
						{
							return DIFeedbackCode.DISuccess;
						}
						valueSubString = this.getvalueSubString(input);
						upperCaseInput = input.ToUpper(); //make case insensitive
						#region if found the end of this section then return success
						if ((upperCaseInput.IndexOf("PARAMETERNAME") == -1) && ( endOfSection( input )== true ))  
						{
							return DIFeedbackCode.DISuccess;
						}
							#endregion if found the end of this section then return success
							#region else if comment then ignore
						else if ( aComment( upperCaseInput ) == true )
						{
						}
							#endregion
							#region else if standard EDS definitions (CAN spec) the check & read in
						else if (upperCaseInput.IndexOf( "SUBNUMBER" ) != -1 )
						{
							tempData.subNumber = (int)sysInfo.convertToUint(valueSubString);
						}
						else if ( upperCaseInput.IndexOf( "PARAMETERNAME" ) != -1 )
						{
							tempData.parameterName = input.Trim().Substring(input.IndexOf( "=" ) + 1);
						}
						else if ( upperCaseInput.IndexOf( "OBJECTTYPE" ) != -1 )
						{
							tempData.objectType = (byte)sysInfo.convertToUint(valueSubString);
						}
						else if ( upperCaseInput.IndexOf( "DATATYPE" ) != -1 )
						{
							tempData.dataType = (byte)sysInfo.convertToUint(valueSubString);
						}
						else if ( upperCaseInput.IndexOf( "LOWLIMIT" ) != -1 )
						{
							tempData.lowLimit = valueSubString.Trim();
						}
						else if ( upperCaseInput.IndexOf( "HIGHLIMIT" ) != -1 )
						{
							tempData.highLimit = valueSubString.Trim();;
						}
						else if ( upperCaseInput.IndexOf( "ACCESSTYPE" ) != -1 )
						{
							tempData.accessType = readAccessType( input, tempData);
						}
						else if ( upperCaseInput.IndexOf( "DEFAULTVALUE" ) != -1 )
						{
							tempData.defaultValue = input.Trim().Substring(input.IndexOf( "=" ) + 1);
							string valueSubStringMinusNodeID  = sysInfo.checkIfEDSParamValueContainsNodeID(valueSubString);
							if(valueSubStringMinusNodeID == valueSubString) //there was no $NODEID in default vlaue
							{
								tempData.defaultType = defaultValType.NORMAL;
							}
							else
							{  //we need to mark defualt vlaue so the DCF is created with same string later
								tempData.defaultType = defaultValType.NODEID_ADDED;
							}
							if ( MAIN_WINDOW.isVirtualNodes == true )
							{   //if this is a virtual system then the initial parameter value
								//MUST be set to EDS defualt
								tempData.parameterValue = new string[1];
								tempData.parameterValue[0] = input.Trim().Substring(input.IndexOf( "=" ) + 1);
							}
						}
						else if ( upperCaseInput.IndexOf( "PDOMAPPING" ) != -1 )
						{
							tempData.PDOmappable = sysInfo.convertToBool(valueSubString);
							if(sysInfo.conversionOK == false)
							{
								SystemInfo.errorSB.Append("Failed to convert ");
								SystemInfo.errorSB.Append(input);
								SystemInfo.errorSB.Append(" to boolean value. Defaulting to non-PDO mappable");
							}
						}
						else if ( upperCaseInput.IndexOf( "OBJFLAGS" ) != -1 )
						{
							tempData.objFlags = (byte)sysInfo.convertToUint(valueSubString);
						}
						else if ( upperCaseInput.IndexOf( "COMPACTSUBOBJ" ) != -1 )
						{
							tempData.compactObj = true;
							tempData.compactNoOfEntries = (int)sysInfo.convertToUint(valueSubString);
						}
						else if ( upperCaseInput.IndexOf( "NAME]" ) != -1 )
						{
							readCompactObjNames( upperCaseInput, objectIdentifier, tempData );
						}
						#endregion
						#region else if Sevcon 'extra' fields then check & read in
						else if((this.EDSdeviceInfo.vendorNumber == SCCorpStyle.SevconID) && ( upperCaseInput.IndexOf( "SEVCONFIELD OBJECT_VERSION" ) != -1 ))
						{
							tempData.object_version = (ushort)sysInfo.convertToUint(valueSubString);
						}
						else if ( 
							(this.EDSdeviceInfo.vendorNumber == SCCorpStyle.SevconID) 
							&& 	(upperCaseInput.IndexOf( "SEVCONFIELD OBJECT" ) != -1 )
							&&  (upperCaseInput.IndexOf( "OBJECT_VERSION" ) == -1 )
							)
						{
							tempData.objectName = readSevconObjectType(valueSubString.ToUpper()  );
						}
						else if ((this.EDSdeviceInfo.vendorNumber == SCCorpStyle.SevconID) && ( upperCaseInput.IndexOf( "SEVCONFIELD SECTION" ) != -1 ))
						{
							tempData.sectionType = readSectionType( valueSubString.ToUpper() );   //sevcon sections are always uppercase
						}
						else if ((this.EDSdeviceInfo.vendorNumber == SCCorpStyle.SevconID) && ( upperCaseInput.IndexOf( "SEVCONFIELD ACCESS_LEVEL" ) != -1 ))
						{
							tempData.accessLevel = (byte)sysInfo.convertToUint(valueSubString);
						}
						else if ((this.EDSdeviceInfo.vendorNumber == SCCorpStyle.SevconID) && ( upperCaseInput.IndexOf( "SEVCONFIELD SCALING" ) != -1 ))
						{
							tempData.scaling = this.sysInfo.convertToDouble( valueSubString);
							if((this.sysInfo.conversionOK == false) || (tempData.scaling <= 0))
							{
								tempData.scaling  = 1;  //failed the conversion default back to 1
							}
						}
						else if ((this.EDSdeviceInfo.vendorNumber == SCCorpStyle.SevconID) && ( upperCaseInput.IndexOf( "SEVCONFIELD UNITS" ) != -1 ))
						{
							tempData.units = input.Trim().Substring(input.IndexOf( "=" ) + 1);
						}
						else if ((this.EDSdeviceInfo.vendorNumber == SCCorpStyle.SevconID) && ( upperCaseInput.IndexOf( "SEVCONFIELD NUMBER_FORMAT" ) != -1 ))
						{
							#region read in Sevcon number formatting
							tempData.format = readSevconFormat( input );

							#region if Sevcon SPECIAL formatting
							/* If special format then need to read in enumerated text strings
															 * which are held in a sorted list (used instead of digits when
															 * displaying to the user.
															 */
							if ( tempData.format == SevconNumberFormat.SPECIAL )
							{
								try
								{
									/* Read number of text strings being defined then read into
																			 * sorted list.
																			 */
									int noOfStrings = (int)sysInfo.convertToUint(valueSubString);
									tempData.formatList = readFormatList( noOfStrings );
								}
								catch ( Exception e )
								{
									long thisLine = this.srLine + 1;;
									SystemInfo.errorSB.Append("\nSevcon format string error ");
									SystemInfo.errorSB.Append(e.Message);
									SystemInfo.errorSB.Append("line: ");
									SystemInfo.errorSB.Append(thisLine.ToString());
									SystemInfo.errorSB.Append(", Error text: ");
									SystemInfo.errorSB.Append(input);
									SystemInfo.errorSB.Append("\nFile: ");
									SystemInfo.errorSB.Append(filepath);
								}
							}
								#endregion
								#region else if Sevcon BIT_SPLIT format
							else if ( tempData.format == SevconNumberFormat.BIT_SPLIT )
							{
								if ( ( input = readLine() ) != null )
								{
									valueSubString = getvalueSubString(input);
									upperCaseInput = input.ToUpper(); //make case insensitive

									if ( input.IndexOf( "SEVCONFIELD NUMBER_SPLIT" ) != -1 )
									{
										int noOfSplits = -1;
										noOfSplits = (int)sysInfo.convertToUint(valueSubString);
										if ( noOfSplits > 0 )
										{
											tempData.split = new DataSplit[ noOfSplits ];
											for(int i = 0;i< tempData.split.Length;i++)
											{
												tempData.split[i] = new DataSplit();
											}
											readBitSplit( tempData);
										}
									}
								}
							}
							#endregion

							#endregion
						}
						else if ( (this.EDSdeviceInfo.vendorNumber == SCCorpStyle.SevconID) && (upperCaseInput.IndexOf( "SEVCONFIELD WRITE_IN_PREOPERATIONAL_ONLY" ) != -1 ))
						{
							tempData.accessType = readWriteInPreOp( input, tempData );
						}
						else if ((this.EDSdeviceInfo.vendorNumber == SCCorpStyle.SevconID) && (  upperCaseInput.IndexOf( "SEVCONFIELD COMMS_TIMEOUT" ) != -1 ))
						{
							tempData.commsTimeout = (int)sysInfo.convertToUint(valueSubString);
						}
						else if ( (this.EDSdeviceInfo.vendorNumber == SCCorpStyle.SevconID) && (upperCaseInput.IndexOf( "SEVCONFIELD DUMMY_VPDO" ) != -1 ))
						{
							tempData.dummyVPDO = (int)sysInfo.convertToUint(valueSubString);
						}
						else if ((this.EDSdeviceInfo.vendorNumber == SCCorpStyle.SevconID) && ( upperCaseInput.IndexOf( ";SEVCONFIELD MASTER" ) != -1 ))
						{
							tempData.displayOnMasterOnly = true;
						}
						else if ((this.EDSdeviceInfo.vendorNumber == SCCorpStyle.SevconID) && (  upperCaseInput.IndexOf( ";SEVCONFIELD TOOLTIP" ) != -1 ))
						{
							bool ToolTipOpen = true;
							tempData.toolTip = readTooltip(input, "=", out ToolTipOpen);
							while ((ToolTipOpen == true) && ( (input = readLine()) != null ))
							{
								tempData.toolTip += this.appendToTooltip(input, out ToolTipOpen);
							}
						}
						else if ((this.EDSdeviceInfo.vendorNumber == SCCorpStyle.SevconID) && (  upperCaseInput.IndexOf( ";SEVCONFIELD EEPROM") != -1))
						{
							if(input.IndexOf("=") != -1)
							{
								tempData.eepromString = input.Trim().Substring(input.IndexOf( "=" ) + 1);
							}
						}
						#endregion
						#region else if DCF file then read parameter value in
						if(filepath.ToUpper().IndexOf(".DCF") != -1)
						{
							if ( ( upperCaseInput.IndexOf( "PARAMETERVALUE" ) != -1 ) || ( upperCaseInput.IndexOf( "UPLOADFILE" ) != -1 ) )
							{ // If parameter value or upload file then read text string into parameterValue.
								tempData.parameterValue = new string[ 1 ];
								tempData.parameterValue[ 0 ] = valueSubString;
							}
								// Else compact objects read in differently.
							else if ( upperCaseInput.IndexOf( "VALUE]" ) != -1 )
							{
								// array of values
								this.readCompactObjParameterValues( upperCaseInput, objectIdentifier, tempData );
							}
						}
						#endregion
					} // end of while ( ( input = readLine() ) != null )
					#endregion Found OD item we're looking for
				} // end of if found section
			} // end of outer while loop
			#region we didn't find the OD item we were looking for - tell user
			SystemInfo.errorSB.Append("\nInvalid object definition for index ");
			SystemInfo.errorSB.Append(objectIdentifier.ToString());
			#endregion we didn't find the OD item we were looking for - tell user
			return ( fbc );
		}

		//-------------------------------------------------------------------------
		//  Name			: rewindEDSfile()
		//  Description     : This function rewinds the file stream reader back to
		//					  the start of the file that is currently open for reading.
		//  Parameters      : None
		//  Used Variables  : fs - file stream
		//					  sr - stream reader
		//					  srPosition - stream reader position
		//					  srLine - stream reader line position
		//  Preconditions   : A file has already been opened for reading and it
		//					  is required to have the stream reader point to the
		//					  start of the file.
		//  Post-conditions : The stream reader points to the start of the file.
		//  Return value    : None
		//--------------------------------------------------------------------------
		///<summary>Rewinds the EDS file stream reader back to the start of the file.</summary>
		internal void rewind(string filepath, FileAccess fileaccess)
		{
			if(EDSorDCFsr != null)
			{
				EDSorDCFsr = null;
			}
			srLine = 0;
			srPosition = 0;
			if(DCFsw != null)
			{
				DCFsw = null;
			}
			if ( EDSorDCFfs.CanSeek == true )
			{
				#region seekable
				try
				{
					EDSorDCFfs.Seek( 0, System.IO.SeekOrigin.Begin );// seek the origin of the file
					#region if file reading or r/w then repoint stream reader to file stream
					if ( ( fileaccess == FileAccess.Read ) || ( fileaccess == FileAccess.ReadWrite ) )
					{
						EDSorDCFsr = new StreamReader( EDSorDCFfs );
					}
					#endregion
					#region if writing or r/w then repoint stream writer to file stream
					if ( ( fileaccess == FileAccess.Write ) || ( fileaccess == FileAccess.ReadWrite ) )
					{
						DCFsw = new StreamWriter( EDSorDCFfs );
					}
					#endregion
				}
				catch ( Exception e )
				{
					#region user feedback
					SystemInfo.errorSB.Append("File rewind error: ");
					SystemInfo.errorSB.Append(e.Message);
					SystemInfo.errorSB.Append(", file: ");
					SystemInfo.errorSB.Append(filepath);
					#endregion user feedback
				}
				#endregion seekable
			}
				// Stream not seekable so must close and reopen to go back to the start of the stream.
			else
			{
				#region else if not seekable then close then reopen the file
				// Stream not seekable so must close and reopen to go back to the start of the stream.
				try
				{
					EDSorDCFfs.Close();
					if ( fileaccess == FileAccess.Read ) 
					{
						#region if file read then reopen the file stream reader
						EDSorDCFfs = new FileStream( filepath, System.IO.FileMode.Open, System.IO.FileAccess.Read );
						EDSorDCFsr = new StreamReader( EDSorDCFfs );
						#endregion
					}
					else if ( fileaccess == FileAccess.ReadWrite)
					{
						#region else reopen the file stream reader and writer
						EDSorDCFfs = new FileStream( filepath, System.IO.FileMode.Open, System.IO.FileAccess.ReadWrite );
						EDSorDCFsr = new StreamReader( EDSorDCFfs );
						DCFsw = new StreamWriter( EDSorDCFfs );
						#endregion
					}
					else if ( fileaccess == FileAccess.Write ) 
					{
						#region else reopen the file stream writer
						EDSorDCFfs = new FileStream( filepath, System.IO.FileMode.OpenOrCreate, System.IO.FileAccess.Write );
						DCFsw = new StreamWriter( EDSorDCFfs );
						#endregion
					}
				}
				catch ( Exception e )
				{
					#region user feedback
					SystemInfo.errorSB.Append("File rewind error: ");
					SystemInfo.errorSB.Append(e.Message);
					SystemInfo.errorSB.Append(", file: ");
					SystemInfo.errorSB.Append(filepath);
					#endregion user feedback
				}
				#endregion
			}
		}

		//-------------------------------------------------------------------------
		//  Name			: endOfSection()
		//  Description     : This function checks the string passed as a parameter
		//					  to see if the end of this section has been found.  This
		//					  is done by checking to see if a new section is started.
		//					  If it is a new section found then we must rewind back
		//					  this last line so that this section start is not missed
		//					  when it needs to be read next.
		//  Parameters      : aString - current line which has beenr read from the file
		//  Used Variables  : None
		//  Preconditions   : aString has been read from the stream reader and it is
		//					  needing checked for end of section.
		//  Post-conditions : Returns if end of section has been found and if the start of
		//					  a new section was found then rewind back one line by the
		//					  stream reader.
		//  Return value    : boolean indicating whether this was the end of an
		//					  EDS section as represented by the aString passed as a parameter
		//--------------------------------------------------------------------------
		///<summary>Checks the string to determine whether the end of the current EDS section has been found.</summary>
		/// <param name="aString">current line which has beenr read from the file</param>
		/// <returns>true if end of section has been found and if the start of a new section was 
		/// found then rewind back one line by the stream reader</returns>
		internal bool endOfSection( string aString )
		{
			bool endOfSection = false;
			// If string is not a null check to see if this is the start of a new section.
			if ( aString != null )
			{
				string trimmedString = aString.Trim();
				#region comments
				/* Compact sub objs use the [xxxxName] and [xxxxValue] to compact section
					 * so still part of the current object's section.
					 * [ in Sevcon fields mustn't be misinterpreted as an end of section.
					 */
				#endregion comments
				if ( ( trimmedString.IndexOf( "[" ) != -1 ) //square barckets allowed in
					&& ( trimmedString.IndexOf( ";SEVCONFIELD" ) == -1 ) //SEVCON fields 
					&& ( trimmedString.ToUpper().IndexOf("PARAMETERNAME") == -1) )//and parameter names
				{
					if ( ( trimmedString.IndexOf( "Name]" ) == -1 ) && ( trimmedString.IndexOf( "Value]" ) == -1 ) )
					{	
						#region comments
						/* Found start of another block - must rewind back this line or we'll 
							 * miss this section when next line is read in from the stream. Doing 
							 * a seek on the file stream didn't work as it must read larger blocks 
							 * and was not tied to the stream reader position. Hence, we manually keep
							 * track of our own stream reader file position by incrementing srPosition
							 * whenever we read from sr and reset it if we reset sr and decrement it
							 * when we do a seek (as below).
							 * Wor on original string, not the trimmed string.
							 */
						#endregion comments
						long offset = aString.Length + Environment.NewLine.Length;

						if ( ( srPosition - offset ) > 0 )
						{
							srPosition -= offset;
							srLine--;
							EDSorDCFsr.BaseStream.Seek( srPosition, SeekOrigin.Begin );
							EDSorDCFsr = new StreamReader( EDSorDCFfs );
							#region comments
							/* If rewound too much (control chars are counted as two in length
									 * but really are only one long in terms of the file stream position),
									 * keep rewinding by one extra character and peeking until the
									 * first character of the previous string matches the peeked character.
									 * This is only important to ensure that a new section [] is not missed.
									 * Control chars in comments are accepted OK in EDS checker which is
									 * what causes this problem.
									 */
							#endregion comments
							for ( int i = 0; i < 400; i ++ )
							{
								if ( EDSorDCFsr.Peek() != aString[ 0 ] )
								{
									char[] buffer = new char[ 1 ];
									srPosition++;
									EDSorDCFsr.Read( buffer, 0, 1 );
								}
								else
								{
									break;
								}
							}
						}
						// End of section was found.
						endOfSection = true;
					}
				}
					#region comments
					/* A blank line is no longer considered end of a section as EDS checker says it's OK.
						 * However, if we peek the next character and it is a '[' then it will be an 
						 * end of section.
						 */
					#endregion comments
				else if ( trimmedString.CompareTo( "" ) == 0 )
				{
					if ( EDSorDCFsr.Peek() == '[' )
					{
						endOfSection = true;
					}
				}
			}
			else
			{
				endOfSection = true;
			}
			return ( endOfSection );
		}

		//-------------------------------------------------------------------------
		//  Name			: readObjectList()
		//  Description     : This function reads the object list (of expected length
		//					  noOfObjects passed as a parameter) and converts from
		//					  text strings into integers.
		//  Parameters        objectList - returned array of integers containing the
		//								   list of object indices read from the EDS file
		//  Used Variables  : None
		//  Preconditions   : EDS file opened and the number of objects expected to be
		//					  detailed has already been read in.
		//  Post-conditions : objectList contains all the object indices to be defined
		//					  in this section.
		//  Return value    : None
		//--------------------------------------------------------------------------
		///<summary>Reads the object list (text format from the EDS) and converts into integers.</summary>
		/// <param name="noOfObjects">expected number of objects to be listed</param>
		/// <param name="objectList">returned array of integers containing the list of object 
		/// indices read from the EDS file</param>
		internal DIFeedbackCode readObjectList( string filepath,  ArrayList objectList )
		{
			#region local variable declarations
			DIFeedbackCode fbc = DIFeedbackCode.DISuccess;
			string input;
			string subString;
			string upperCaseInput;
			#endregion

			#region read next line of file & check if it contains supported section
			input = readLine();
			while ( ( input != null ) && ( endOfSection( input) == false ) )
			{
				// convert to upper case & strip out potentially misleading comments
				removePartLineComments( input );
				upperCaseInput = input.ToUpper();

				if ( endOfSection( input ) == true )
				{
					SystemInfo.errorSB.Append("\nZero objects in list");
					return fbc;
				}
					#region if supported object section found (not in comment) read number of objects
				else if ( ( upperCaseInput.IndexOf( "SUPPORTEDOBJECTS" ) != -1 ) && ( aComment( upperCaseInput ) == false ) )
				{
					// read the number of objects in this section
					subString = input.Trim().Substring(input.IndexOf( "=" ) + 1);
					uint noOfObjects = sysInfo.convertToUint( subString );
					#region for each object in list, extract the object index & convert to an integer
					for ( int thisObject = 0; thisObject < noOfObjects; thisObject++ )
					{				
						input = readLine();
                        if ((input != null) && (input != "")) //DR38000260 prevent exception
						{
							removePartLineComments( input );
							upperCaseInput = input.ToUpper();

							#region if not a comment then extract digit & add to object list
							if ( aComment( upperCaseInput )== false )
							{
								string temp = upperCaseInput.Substring(upperCaseInput.IndexOf("0X") + 2);
								objectList.Add(temp);
							}
							#endregion
						}
					}
					#endregion

                    //DR38000260 Report if supportedObjects number doesn't match no. of indices read from file
                    if (objectList.Count < noOfObjects)
                    {
                        fbc = DIFeedbackCode.DIMissingSupportedObjectsInEDSorDCF;
                        SystemInfo.errorSB.Append("\nMissing SupportedObject definition: expected " + noOfObjects.ToString() + " objects but only " + objectList.Count.ToString() + " were defined in EDS/DCF file.");
                    }
					return fbc;
				}	
				else
				{
					input = readLine();
				}
				#endregion
			}
			#endregion
			return fbc;
		}

		internal string readTooltip(string input, string searchString, out bool ToolTipOpen)
		{
			ToolTipOpen = true;
			string subString = input.Trim().Substring(input.IndexOf( searchString ) + searchString.Length);; 
			//lose all chars upto and including opening double quote
			int firstHash = subString.IndexOf('#');
			subString = subString.Substring(firstHash + 1);
			int lastHash = subString.LastIndexOf("#");
			if(firstHash != lastHash) 
			{
				subString = getToolTipText(lastHash, subString, ref ToolTipOpen);
			}
			return subString;
		}
		private string getToolTipText(int lastHash, string subString, ref bool ToolTipOpen)
		{
			int inlineHash = subString.LastIndexOf("\\#") + 1; //point to # not \
			if((lastHash != -1) && (lastHash != inlineHash))
			{
				ToolTipOpen = false;
				subString = subString.Substring(0, lastHash);
			}
			subString = subString.Replace("\\#", "#");
			subString = subString.Replace(@"\n", System.Environment.NewLine);
			return subString;
		}
		internal string appendToTooltip(string input, out bool ToolTipOpen)
		{
			ToolTipOpen = true;
			string subString = input.Substring(1, input.Length - 1);  //lose the leading semicolon
			int lastHash = subString.LastIndexOf("#");
			subString = getToolTipText(lastHash, subString, ref ToolTipOpen);
			return subString;
		}
		//-------------------------------------------------------------------------
		//  Name			: readFormatList()
		//  Description     : This function reads the formatList for an enumerated data
		//					  type object from the the following EDS lines to
		//					  read the Sevcon specific text strings to be displayed 
		//					  instead of the digit (eg 1=set,0=reset).
		//  Parameters      : noOfFormatStrings - number of enumerated strings
		//										  expected to read from EDS
		//  Used Variables  : None
		//  Preconditions   : noOfFormatStrings contains expected number of enums and
		//					  EDS file has been opened for reading and stream reader
		//					  is pointing to correct section of file detailing enum.
		//  Post-conditions : formatList contains list of DriveWizard.SCCorpStyle.MaxNoOfEnumeratedValues 
		//				      enumerated types, containing all the defaults and with those 
		//					  defined in the EDS file replacing the appropriate defaults.
		//  Return value    : formatList (as post-conditions)
		//--------------------------------------------------------------------------
		///<summary>Reads the enumerated text strings for Sevcon SPECIAL data from the EDS file.</summary>
		/// <param name="noOfFormatStrings">number of enumerated strings expected to read from EDS</param>
		/// <returns>formatList contains list of DriveWizard.SCCorpStyle.MaxNoOfEnumeratedValues
		/// enumerated types, containing all the defaults and with those defined in the EDS file 
		/// replacing the appropriate default</returns>
		internal string readFormatList( int noOfFormatStrings )
		{
			#region local variable declarations and variable initialisation
			string [] split = null;
			string input, upperCaseInput;
			string delimitedFormatList = "";
			int line;
			#endregion

			#region Replace those items in the formatList which have a Sevcon string assigned

			// For each line with a Sevcon string associated, read, extract & replace in list
			for ( line = 0; line < noOfFormatStrings; line++ )
			{
				// if not end of the file then check to replace default enum string with Sevcon string
				if ( ( input = readLine() ) != null )
				{			
					#region convert to upper case and remove any comments
					removePartLineComments( input );
					upperCaseInput = input.ToUpper();
					#endregion

					#region if end of section found then quit the loop
					if ( endOfSection( input ) )
					{
						// Found the start of another section so quit this loop
						break;
					}
						#endregion
						#region else ignore any comments
					else if ( aComment( upperCaseInput) == true )
					{
						// ignore any comments
					}
						#endregion
						#region else potential Sevcon replacement string for enumerated type
					else 
					{
						#region find SEVCONFIELD string and strip out
						if ( upperCaseInput.IndexOf( "SEVCONFIELD " ) != -1 )
						{
							input = input.Substring("SEVCONFIELD ".Length);
						}
						else
						{
							input = "";
						}
						#endregion

						#region split string, convert digit part then add other string to approp. part of list
						/* A valid format so split into two strings, one with xxxx (number)
							* and the other with the text descriptor.
							*/
						split = input.Split( '=' );

						/* Convert number from hex text string to UInt16 and leave
							* descriptor as a text string.
							*/
						if ( split.Length >= 2 )
						{  //judetemp some eunerateds ar enow very long eg EVAS - we need to be able to accomodate all 64bit numbers 
							//we can eithe rpad likeke this ans splita t knwon point or we can decide on a delimiter that is never used imn param name 
							//we could reuse ':' but this will need more processing later on- use the padding for now
							bool isNum = true;
							if(	split[0].ToUpper().IndexOf("0X") != -1)
							{ //hex 
								try
								{
									long val = System.Convert.ToInt64( split[0].Trim(), 16);// + split[ 0 ].Substring(indexOf0x +2).PadLeft(16, '0');
								}
								catch
								{
									isNum = false;
								}
							}
							else
							{//base 10
								try
								{
									long val =System.Convert.ToInt64( split[0].Trim());
								}
								catch
								{
									isNum = false;
								}
							}
							if(isNum == true)
							{
								delimitedFormatList = delimitedFormatList + input + ":";//split[ 1 ] + "_" + tempNumberString +":";
							}
							else
							{
								SystemInfo.errorSB.Append("\nFailed to read all enumerated Sevcon Number formats. Faulty Text: ");
								SystemInfo.errorSB.Append(input);
							}
						}
						#endregion
					}
					#endregion
				}
			}
			if ( delimitedFormatList.Length > 1 )
			{ //remove last ':'
				delimitedFormatList = delimitedFormatList.Remove( delimitedFormatList.Length - 1, 1 );
			}
			#endregion
			return ( delimitedFormatList );
		}
		//-------------------------------------------------------------------------
		//  Name			: readAccessType()
		//  Description     : This function ascertains the access type for this object
		//					  taking into consideration the CANopen access type and the
		//					  Sevcon additional field writeOnlyInPreOp from the EDS file.
		//  Parameters      : input - line read in from the EDS/DCF file
		//					  tempData - EDSobject which contains the writeOnlyInPreOp
		//								field to be taken into consideration when
		//								determing the access type.
		// Used Variables  : None
		// Preconditions   : tempData.writeOnlyInPreOp contains latest value for this
		//					  object (could be declared before or after access type)
		//					  and input contains relevant line of EDS containing the
		//					  access type (CANopen style) for the object of interest.
		//  Post-conditions : type contains the object access type which is derived
		//					  from a combination of the CANopen access type and the
		//					  Sevcon additional field writeOnlyInPreOp.
		//  Return value    : type (as post-conditions)
		//--------------------------------------------------------------------------
		///<summary>Determines the access type based on the CANopen access type and the Sevcon writeOnlyInPreOp field.</summary>
		/// <param name="input">line read in from the EDS/DCF file</param>
		/// <param name="tempData">EDSobject which contains the writeOnlyInPreOp field to be taken 
		/// into consideration when determing the access type</param>
		/// <returns>type contains the object access type which is derived from a combination of the 
		/// CANopen access type and the Sevcon additional field writeOnlyInPreOp</returns>
		internal ObjectAccessType readAccessType( string input, EDSObjectInfo tempData )
		{
			#region local variable declarations and variable initialisation
			ObjectAccessType type = ObjectAccessType.ReadOnly;
			string upperCaseInput;
			#endregion

			// Make case insensitive.
			upperCaseInput = input.ToUpper();

			#region if read read write
			if ( upperCaseInput.IndexOf( "RRW" ) != -1 )
			{
				// If already read Sevcon additional field indicating only in preop then update type
				if ( tempData.writeOnlyInPreOp == true )
				{
					type = ObjectAccessType.ReadReadWriteInPreOp;
				}
				else
				{
					type = ObjectAccessType.ReadReadWrite;
				}
			}
				#endregion
				#region else if read write write
			else if ( upperCaseInput.IndexOf( "RWW" ) != -1 )
			{
				// If already read Sevcon additional field indicating only in preop then update type
				if ( tempData.writeOnlyInPreOp == true )
				{
					type = ObjectAccessType.ReadWriteWriteInPreOp;
				}
				else
				{
					type = ObjectAccessType.ReadWriteWrite;
				}
			}
				#endregion
				#region else if read only
			else if ( upperCaseInput.IndexOf( "RO" ) != -1 )
			{
				// read only unaffected by Sevcon only in preop field
				type = ObjectAccessType.ReadOnly;
			}
				#endregion
				#region else if write only
			else if ( upperCaseInput.IndexOf( "WO" ) != -1 )
			{
				// If already read Sevcon additional field indicating only in preop then update type
				if ( tempData.writeOnlyInPreOp == true )
				{
					type = ObjectAccessType.WriteOnlyInPreOp;
				}
				else
				{
					type = ObjectAccessType.WriteOnly;
				}
			}
				#endregion
				#region else if read write
			else if ( upperCaseInput.IndexOf( "RW" ) != -1 )
			{
				// If already read Sevcon additional field indicating only in preop then update type
				if ( tempData.writeOnlyInPreOp == true )
				{
					type = ObjectAccessType.ReadWriteInPreOp;
				}
				else
				{
					type = ObjectAccessType.ReadWrite;
				}
			}
				#endregion 
				#region else if constant 
			else if ( upperCaseInput.IndexOf( "CONST" ) != -1 )
			{
				// constant data type unaffected by Sevcon field only in preop
				type = ObjectAccessType.Constant;
			}
				#endregion
			else
			{
				SystemInfo.errorSB.Append("\nInvalid Object Access Type. Line No");
				SystemInfo.errorSB.Append((this.srPosition + 1).ToString());
				SystemInfo.errorSB.Append("Text: ");
				SystemInfo.errorSB.Append(input);
			}
			return ( type );
		}

		//-------------------------------------------------------------------------
		//  Name			: readSectionType()
		//  Description     : This function takes the SevconSectionType declared as a 
		//					  text string in the input (text string) and converts this
		//					  into an enumerated data type value match.
		//  Parameters      : input - line read in from the EDS/DCF file
		//  Used Variables  : None
		//  Preconditions   : input contains relevant line for this object from the
		//					  EDS/DCF file which should contain Sevcon Section Type.
		//  Post-conditions : type contains the SevconsectionType enum data equivalent
		//					  of the type contained within the input text string (unless
		//					  unrecognised type).
		//  Return value    : as post-conditions.
		//--------------------------------------------------------------------------
		///<summary>Converts the Sevcon section type from string format to enumerated SevconSectionType format.</summary>
		/// <param name="input">line read in from the EDS/DCF file</param>
		/// <returns>type contains the SevconsectionType enum data equivalent of the type contained within 
		/// the input text string (unless it is an unrecognised type)</returns>
		internal int readSectionType( string input)
		{
			int type = (int)SevconSectionType.NONE;
			#region try and match this to one of our enuerated items
			try
			{
                if (sysInfo.sevconSectionIDList.Contains(input) == false)
                {
                    sysInfo.sevconSectionIDList.Add(input);
                }

				type = sysInfo.sevconSectionIDList.IndexOf(input);
			}
			catch
			{
				type = (int)SevconSectionType.UNASSIGNED;
				//this section typ ename was not in DriveWizard's enumerated list
				//for locating these items under the "unassgied tree node"
				if(nodeInfo.nonAssigedEDSSections.Contains(input) == false)
				{
					nodeInfo.nonAssigedEDSSections.Add(input);
					MAIN_WINDOW.masterEDSSections.Add(input);  //for future use
					#region user feedback
					SystemInfo.errorSB.Append("\nUnknown Sevcon EDS Section: ");
					SystemInfo.errorSB.Append(input);
					#endregion user feedback
				}

			}
			#endregion  try and match this to one of our enuerated items
			return ( type );
		}

		//-------------------------------------------------------------------------
		//  Name			: readSevconObjectType()
		//  Description     : This function takes the SevconObjectType declared as a 
		//					  text string in the input (text string) and converts this
		//					  into an enumerated data type value match.
		//  Parameters      : input - line read in from the EDS/DCF file
		//  Used Variables  : None
		//  Preconditions   : input contains relevant line for this object from the
		//					  EDS/DCF file which should contain Sevcon Object Type.
		//  Post-conditions : type contains the SevconObjectType enum data equivalent
		//					  of the type contained within the input text string (unless
		//					  unrecognised type).
		//  Return value    : as post-conditions.
		//--------------------------------------------------------------------------
		///<summary>Converts the Sevcon objet type from string format to enumerated SevconObjectType format.</summary>
		/// <param name="input">line read in from the EDS/DCF file</param>
		/// <returns>type contains the SevconObjectType enum data equivalent of the type contained within the 
		///  input text string (unless it is an unrecognised type)</returns>
		internal int readSevconObjectType( string valueSubStringUpper )
		{
			int type = (int)SevconObjectType.NONE;
			try
			{
                if (sysInfo.sevconObjectIDList.Contains(valueSubStringUpper) == false)
                {
                    sysInfo.sevconObjectIDList.Add(valueSubStringUpper);
                }

                type = sysInfo.sevconObjectIDList.IndexOf(valueSubStringUpper);
            }
			catch
			{
				type = (int)SevconObjectType.NONE;
				#region user feedback
				SystemInfo.errorSB.Append("\nUnassigned Sevcon Object Type. Line no: "); 
				SystemInfo.errorSB.Append((this.srLine + 1).ToString());
				SystemInfo.errorSB.Append(", Text: ");
				SystemInfo.errorSB.Append(valueSubStringUpper);
				#endregion user feedback
			}
			return ( type );
		}

		//-------------------------------------------------------------------------
		//  Name			: readSevconFormat()
		//  Description     : This function reads the input text string read from the 
		//					  EDS file and parses this to determine the number format
		//					  that DW must display this object's value as to the user
		//					  for best comprehesion (base 10, 16 or special).
		//					  Default is base 10 for non Sevcon objects etc.
		//  Parameters      : input - line read in from the EDS/DCF file
		//  Used Variables  : None
		//  Preconditions   : input contains relevant line for this object from the
		//					  EDS/DCF file which should contain Sevcon number format.
		//  Post-conditions : type contains the SevconNumberFormat enum data equivalent
		//					  of the type contained within the input text string (unless
		//					  unrecognised type).
		//  Return value    : type - number format DW has to use to display this
		//					  object's value to the user (base 10, 16 or special)
		//--------------------------------------------------------------------------
		///<summary>Determines from the input string the number format to use to display this object in DW.</summary>
		/// <param name="input">line read in from the EDS/DCF file</param>
		/// <returns>type contains the SevconNumberFormat enum data equivalent of the type contained 
		/// within the input text string (unless it is an unrecognised type)</returns>
		internal SevconNumberFormat readSevconFormat( string input)
		{
			// If no match then assumed to be base 10
			SevconNumberFormat type = SevconNumberFormat.BASE10;

			#region clean up input text string and find the text substring after the '='
			input = input.TrimStart( ' ' );
			input = input.TrimEnd( ' ' );
			input = input.ToUpper();
			input = input.Trim().Substring(input.IndexOf( "=" ) + 1);
			#endregion

			#region if SEVCONFIELD contains BASE then number format expected is 10 or 16
			if ( ( input.IndexOf( "BASE" ) != -1 ) || ( input.IndexOf( SevconNumberFormat.BIT_SPLIT.ToString() ) != -1 ) )
			{
				#region check this text string against every known possible enum match
				// NOTE: enumerated name type must exactly match the text string identifier in the EDS file.
				for ( int i = 0; i < SevconNumberFormat.LAST_SEVCON_FORMAT_TYPE.GetHashCode(); i++ )
				{
					// convert sevcon number format enum data type to a string and search input for a match
					int indexOf = input.IndexOf( type.ToString() );

					// If a match is found, check it's a complete match.
					if ( indexOf  != -1 )
					{
						/* Check at end of line because SDO_PARAM1 is a sub of SDO_PARAM12
						 * and could pick it up wrongly.
						 */
						if ( ( indexOf + type.ToString().Length ) >= input.Length )
						{
							// exact match found so quit the loop
							break;
						}
					}
					
					// keep a copy of number of match being tested (used below)
					type++;
				}
				#endregion

				#region if didn't find a match then must be that no number format recognised/declared.
				if ( type == SevconNumberFormat.LAST_SEVCON_FORMAT_TYPE )
				{
					SystemInfo.errorSB.Append("\nUnrecognised Sevcon Format Type. Line no: ");
					SystemInfo.errorSB.Append((this.srLine + 1).ToString());
					SystemInfo.errorSB.Append(", Text: ");
					SystemInfo.errorSB.Append(input);
				}
				#endregion
			}
				#endregion
				#region else number format is special (enumerated text strings) so read no. defined in EDS
			else
			{
				try
				{
					// Read the number of enum text strings expected to be defined in EDS file
					int special = System.Convert.ToInt16( input, 16 );

					if ( special > 0 )
					{
						type = SevconNumberFormat.SPECIAL;
					}
				}
				catch ( Exception e )
				{
					SystemInfo.errorSB.Append("\nUnrecognised Sevcon Format Type. Error code:");
					SystemInfo.errorSB.Append(e.Message);
					SystemInfo.errorSB.Append(" Line no: ");
					SystemInfo.errorSB.Append((this.srLine + 1).ToString());
					SystemInfo.errorSB.Append(", Text: ");
					SystemInfo.errorSB.Append(input);
				}
			}
			#endregion

			return ( type );
		}

		//-------------------------------------------------------------------------
		//  Name			: readObjectDescriptions()
		//  Description     : This function reads in turn each object description (and all
		//					  its subs) in the objectList from the EDS file and then
		//					  adds them to the object dictionary the DW is building up.
		//  Parameters      : objectList - array of strings of the indices for which
		//								  their descriptions have to be read in from the
		//								  EDS file
		//					  objectDictionary - jagged array (index by subs) representing
		//									this node's replica of the OD.
		//  Used Variables  : None
		//  Preconditions   : objectList contains a list of indices that should be defined
		//					  in this EDS file which has already been opened for reading.
		//  Post-conditions : objectDictionary contains the new objectData objects which
		//					  represent the EDS data for each of the objects in objectList
		//					  and for all their sub-indices.
		//  Return value    : fbc indicates success or gives the failure reason
		//--------------------------------------------------------------------------
		///<summary>Reads each object description (and subs) listed in the objectList from the EDS.</summary>
		/// <param name="objectList">array of strings of the indices for which their descriptions 
		/// have to be read in from the EDS file</param>
		/// <param name="od">jagged array (index by subs) representing this node's replica of the OD</param>
		/// <param name="EDSObjectType">which section of the EDS this object resides in 
		/// (ie mandatory, optional or manufacturer)</param>
		/// <returns>feedback indicates success or gives a failure reason</returns>
		internal DIFeedbackCode readObjectDescriptions( string filepath, ArrayList objectList, CANObjectType EDSObjectType, nodeInfo CANnode )
		{
			#region local variable declarations and variable initialisation
			EDSObjectInfo objectData;
			string searchString;
			int noOfSubs;
			DIFeedbackCode fbc = DIFeedbackCode.DISuccess;
			DIFeedbackCode firstFail = DIFeedbackCode.DISuccess;
			#endregion

			rewind(filepath, FileAccess.Read);
			
			#region read each object in turn and use to create the object dictionary
			if ( objectList != null )
			{
				foreach ( string thisObject in objectList )
				{
					objectData = new EDSObjectInfo(); //create an EDS OD object
					// keep a note of which EDS section it's on for generating DCFs
					objectData.EDSObjectType = EDSObjectType;
					#region build index string to search for eg "[1234]"
					objectData.indexNumber = (int)sysInfo.convertToUint( "0X" + thisObject ); //it is in hex so add leading 0x so conversion  method realises
					#endregion
				

					// find required object in EDS and read object details into objectData
					searchString = "[" + thisObject.ToUpper() + "]";
					fbc = readObjectDescription( filepath, searchString, objectData);
					#region if read OK then set accessType & set in object dictionary
					if ( fbc == DIFeedbackCode.DISuccess )
					{
						/* There is no data associated with the index when subs exist.
						 * Also make the sub number invalid to prevent accidental match. */
						if ( objectData.subNumber < 0 )
						{
							objectData.accessType = ObjectAccessType.DWDisplayOnly;
						}
						fbc = CANnode.setObjectDescription( objectData, this );
						noOfSubs = objectData.subNumber;
					}
						#endregion
						#region else not read OK so set failure flag & clear number of subs
					else
					{
						if(firstFail == DIFeedbackCode.DISuccess)
						{
							firstFail = fbc;
						}
						noOfSubs = 0;
						SystemInfo.errorSB.Append("\nOD Item is in Supported Objects list but has no details in the file.  OD Index:0x");
						SystemInfo.errorSB.Append(objectData.indexNumber.ToString("X").PadLeft(4, '0'));
						SystemInfo.errorSB.Append(", SubIndex: ");
						if(objectData.subNumber>1)
						{
							SystemInfo.errorSB.Append(objectData.subNumber.ToString("X").PadLeft(3,'0'));
						}
						else
						{
							SystemInfo.errorSB.Append("Header");
						}
					}
					#endregion

					#region if subs exist for this object then read each one & create in the OD
					if ( noOfSubs > 0 )
					{
						// create search string for a sub eg "[1234SUB"
						searchString = "[" + thisObject.ToUpper() + "SUB";
						#region for each sub read in details from EDS & create & set in the OD
						for ( int eachSub = 0; eachSub < noOfSubs; eachSub++ )
						{
							// load default values in objectData ready to read next object from EDS
							objectData = new EDSObjectInfo();
							// convert object from string to int (base16) and set in objectData
							objectData.indexNumber = (int)sysInfo.convertToUint( "0X" + thisObject ); //it is in hex so add leading 0x so conversion  method realises
							// note which EDS section it's on for generating DCFs
							objectData.EDSObjectType = EDSObjectType;
							// read searchString object details from EDS into objectData
							fbc = readObjectDescription( filepath, searchString, objectData);

							#region if sub-object read OK then set in OD else set failure flag
							if ( fbc == DIFeedbackCode.DISuccess )
							{
								CANnode.setSubDescription( objectData, this );
							}
							else
							{
								if(firstFail == DIFeedbackCode.DISuccess)
								{
									firstFail = fbc;
								}
								SystemInfo.errorSB.Append("\nFailed to find add object to  dictionary.EDS Index:0x");
								SystemInfo.errorSB.Append(objectData.indexNumber.ToString("X").PadLeft(4, '0'));
								SystemInfo.errorSB.Append(", SubIndex: ");
								if(objectData.subNumber>1)
								{
									SystemInfo.errorSB.Append(objectData.subNumber.ToString("X").PadLeft(3,'0'));
								}
								else
								{
									SystemInfo.errorSB.Append("Header");
								}
							}
							#endregion
						}
						ObjDictItem odItem  = CANnode.getODItemAndSubs(objectData.indexNumber);
						if(odItem != null)
						{
							CANnode.updateSubNumsForBitSplitSubItems(odItem);
						}
						#endregion
					}
					#endregion
				}
			}
			#endregion
			return ( firstFail );
		}

		//-------------------------------------------------------------------------
		//  Name			: aComment()
		//  Description     : This function checks the current line of text from the EDS
		//					  file (input) to see whether it is a comment or not.
		//					  Comments need to be ignored because often they contain
		//					  old parts of the EDS commented out as it's out of date.
		//					  So it may have the correct syntax and so must be 
		//					  deliberately ignored.
		//					  There are comment blocks (several lines must be ignored)
		//					  and there are single line comments, starting with a ';'.
		//  Parameters      : input - latest line of text read from the EDS file to 
		//							  be checked if it is a comment or not
		//  Used Variables  : None
		//  Preconditions   : EDS file has been opened for reading and input contains
		//					  the latest line read from the file.
		//  Post-conditions : isAComment is set to true if it is a comment block or
		//					  a single line comment was in input
		//  Return value    : As post-conditions
		//--------------------------------------------------------------------------
		///<summary>Checks the input string to determine whether it is a comment.</summary>
		/// <param name="input">latest line of text read from the EDS file to be checked if 
		/// it is a comment or not</param>
		/// <returns>isAComment is set to true if it is a comment block or a single line comment was in input</returns>
		internal bool aComment( string input)
		{
			#region local variable declarations and variable initialisation
			bool	isAComment = false;
			string	upperCaseInput;
			char [] charArray = new char[ input.Length + 1 ];
			int		noOfCommentLines = 0;
			#endregion

			#region if the start of a comment block then read & ignore to the end of the section
			if ( input.IndexOf( "[COMMENTS]" ) != -1 )
			{
				// set return value to true
				isAComment = true;

				#region Find how many lines are in this comment block
				while ( ( input = readLine()) != null )
				{
					string valueSubString = this.getvalueSubString(input);
					// make case insensitive and remove potential confusing part line comments
//					removePartLineComments( input );
					upperCaseInput = input.ToUpper();

					if ( upperCaseInput.IndexOf( "LINES" ) != -1 )
					{
						noOfCommentLines = (int)sysInfo.convertToUint(valueSubString);
						// quit the loop as found how many lines in comment block
						break;
					}
				}
				#endregion

				#region read from the stream the stated number of comment lines so they are ignored.
				for ( int line = 0; line < noOfCommentLines; line++ )
				{
					input = readLine();

					// quit loop if end of file was found
					if ( input == null )
					{
						break;
					}
				}
				#endregion
			}
				#endregion
				#region else is it a single line comment then ignore just this line
			else
			{
				// Only check for other comment types if the input string isn't a null
				if ( input != "" )
				{
					// convert from a string to an array of characters
					charArray = input.ToCharArray( 0, input.Length );

					#region if this is a single line comment
					if ( charArray[ 0 ] == ';' )
					{
						#region if it's a SEVCONFIELD then it's not really a comment (to us)
						if ( input.IndexOf( ";SEVCONFIELD" ) != -1 )
						{
							isAComment = false;
						}
							#endregion
							#region else it's a single line comment
						else
						{
							isAComment = true;
						}
						#endregion
					}
					#endregion
				}
			}
			#endregion
			return ( isAComment );
		}

		//-------------------------------------------------------------------------
		//  Name			: removePartLineComments()
		//  Description     : This function checks the input line of text to see
		//					  if there is a part line comment at the end of the
		//					  text (starts with ';'). If so, this is stripped from
		//					  the input text string and the remainder of the string
		//					  is returned.
		//  Parameters      : input - latest line of text read from the EDS file to 
		//							  be checked if it is has parital comment or not
		//  Used Variables  : None
		//  Preconditions   : EDS file has been opened for reading and input contains
		//					  the latest line read from the file.
		//  Post-conditions : input has been modified to strip out any partial line
		//					  comments.
		//  Return value    : None
		//--------------------------------------------------------------------------
		///<summary>Removes any part line comments from the input string.</summary>
		/// <param name="input">latest line of text read from the EDS file to be checked if 
		/// it has a partial comment or not </param>
		internal void removePartLineComments( string input )
		{
			#region comments
			/*
			 * If part of the line is a comment, then copy the non-comment part of
			 * the line into input (so that any commented out 'proper' syntax is 
			 * not accidently read).
			 */
			#endregion comments
			if ( input != "" )
			{
				int startOfComment = input.Trim().IndexOf( ";" );
				if ( startOfComment != -1 ) 
				{
					if ( input.IndexOf( ";SEVCONFIELD" ) == startOfComment ) 
					{
						// Sevcon additional information in a comment field so leave it in.
					}
					else if ( startOfComment >= 0 )
					{
						input = input.Substring( 0, startOfComment );
					}
				}
			}
		}

		//-------------------------------------------------------------------------
		//  Name			: readLine(this.EDSorDCFsr, this.srPosition, this.srLine)
		//  Description     : This function is used to read the next line of text
		//					  in from the EDS file stream reader.  The line number
		//					  and the character position of the stream are updated
		//					  and handled manually so that successful rewinds
		//					  of the stream reader can be performed OK (found
		//					  problem when doing random file seeks using given
		//					  library routines).  The latest line of text read
		//					  in from the EDS file is returned.
		//  Parameters      : None
		//  Used Variables  : sr - stream reader for EDS file
		//					  srLine - current line position of the stream reader
		//					  srPosition - current character position of the stream reader
		//  Preconditions   : EDS file has been opened for reading.
		//  Post-conditions : input contains the next line of text read in from the EDS
		//					  file and srLine and srPosition are updated to reflect the
		//					  new position in the EDS reader stream.
		//  Return value    : input - latest line of text read in from the EDS.
		//--------------------------------------------------------------------------
		///<summary>Reads one line of text from the EDS file and updates stream position pointers.</summary>
		/// <returns>input contains the next line of text read in from the EDS file and srLine and 
		/// srPosition are updated to reflect the new position in the EDS reader stream</returns>
		internal string readLine()
		{
			// Read in the latest line from the opened EDS stream reader
			string input = this.EDSorDCFsr.ReadLine();
			// increment the current line number
			this.srLine++;
			// increment the actual stream position in the EDS (number of chars read so far)
			if ( input != null )
			{
				srPosition += input.Length + Environment.NewLine.Length;
			}
			return ( input );
		}

		#endregion

		#region private functions
		//-------------------------------------------------------------------------
		//  Name			: readCompactObjNames() 
		//  Description     : This function reads in the compact sub object descriptor
		//					  names into the tempData object. Checks are made that
		//					  compact subs are defined in the EDS.
		//  Parameters      : header - line of text read from EDS which is checked to see
		//							   if it is the compact sub name section header
		//					  objectIdentifier - object index (as a string) that is
		//							   requiring subs descriptors to be read from this section
		//					  tempData - place to store the compact sub descriptors read in
		//  Used Variables  : None
		//  Preconditions   : EDS file was opened for reading and objectIdentifier object
		//					  is already known to have a compact description.  Header
		//					  already checked/expected to contain the  NAME section header.
		//  Post-conditions : tempData populated with compact descriptors read in for
		//					  objectIdentifier object from the EDS file.
		//  Return value    : As post-conditions.
		//--------------------------------------------------------------------------
		///<summary>Reads in the compact sub object descriptor names from the EDS and places in tempData.</summary>
		/// <param name="header">line of text read from EDS which is checked to see if it 
		/// is the compact sub name section header</param>
		/// <param name="objectIdentifier">object index (as a string) that is requiring 
		/// subs descriptors to be read from this section</param>
		/// <param name="tempData">tempData populated with compact descriptors read in for 
		/// objectIdentifier object from the EDS file</param>
		private void readCompactObjNames( string header, string objectIdentifier, EDSObjectInfo tempData )
		{
			#region local variable declarations and variable initialisation
			string input;
			string upperCaseInput;
			int noOfEntries = 0;
			int entriesRead = 0;
			#endregion

			// Trim trailing ] from the object string eg [1234] -> [1234
			objectIdentifier = objectIdentifier.Trim( ']' );
							
			#region if compact name header section found & expecting it then read in compact descriptions
			if ( ( header.IndexOf( objectIdentifier + "NAME]" ) != -1 )	&& ( tempData.compactObj == true ) )
			{
				#region while not end of the file & not new section then read in compact descritions
				while ( ( input = readLine() ) != null )
				{
					string valueSubString = this.getvalueSubString(input);
//					removePartLineComments( input );
					upperCaseInput = input.ToUpper();

					#region if end of this section then quit this loop
					if ( endOfSection( input ) )
					{
						// Found the start of another section so quit this loop
						break;
					}
						#endregion
						#region else if line defines number of compact entries then read & set
					else if ( upperCaseInput.IndexOf( "NROFENTRIES" ) != -1 )
					{
						noOfEntries = (int)sysInfo.convertToUint(valueSubString);
						tempData.compactNames = new string[ noOfEntries ];
						entriesRead = 0;
					}
						#endregion
						#region else if line contains compact text description then read in
					else if ( upperCaseInput.IndexOf( "=" ) != -1 )
					{
						if ( entriesRead < tempData.compactNames.Length )
						{
							tempData.compactNames[ entriesRead ] = input;
							entriesRead++;
						}
						else
						{
							break;
						}
					} 
					#endregion
				}
				#endregion
			}
			#endregion
		}

		//-------------------------------------------------------------------------
		//  Name			: readWriteInPreOp()
		//  Description     : This function reads the WRITE_IN_PREOPERATIONAL_ONLY
		//					  boolean valuen in from the input string of the EDS file
		//					  and uses this to update the accessType, taking into
		//					  account the accessType already found in the tempData 
		//					  structure.
		//  Parameters      : input - current line read from the EDS with IN_PREOP flag
		//					  tempData - populated data structure (so far) for the 
		//								current object being read in from the EDS
		//  Used Variables  : None
		//  Preconditions   : input contains the IN_PREOP flag as read from the EDS
		//					  and tempData contains the information read so far from
		//					  the EDS for the current object.
		//  Post-conditions : accessType is set according to WRITE_IN_PREOPERATIONAL_ONLY
		//					  and tempData.accessType 
		//  Return value    : accessType - updated access type after reading in the
		//					  WRITE_IN_PREOPERATIONAL_ONLY boolean from the EDS file
		//--------------------------------------------------------------------------
		///<summary>Reads the write in PreOp only parameter in the input string and updates tempData accoringly.</summary>
		/// <param name="input">current line read from the EDS with IN_PREOP flag</param>
		/// <param name="tempData">populated data structure (so far) for the current 
		/// object being read in from the EDS</param>
		/// <returns>accessType is set according to WRITE_IN_PREOPERATIONAL_ONLY and 
		/// tempData.accessType</returns>
		private ObjectAccessType readWriteInPreOp( string input, EDSObjectInfo tempData )
		{
			ObjectAccessType accessType = tempData.accessType;
			int  indexOfEquals = -1;

			// WRITE_IN_PREOPERATIONAL_ONLY=true format expected in EDS file

			#region check input string & extract the string found after the '=' sign 
			indexOfEquals = input.IndexOf( "=" );

			if ( indexOfEquals != -1 )
			{
				indexOfEquals++;	// point to next character after the '='
				input = input.Substring( indexOfEquals, ( input.Length - indexOfEquals ) );
			}
			#endregion

			#region clean up input string & make case insensitive
			input = input.Trim().ToUpper();
			#endregion

			#region if 'TRUE' in substring then set the accessType to equivalent for in pre-op
			if ( input.IndexOf( "TRUE" ) != -1 )
			{
				tempData.writeOnlyInPreOp = true;

				switch ( accessType )
				{
						#region ReadWrite -> ReadWriteInPreOp
					case ObjectAccessType.ReadWrite: 
					{ 
						accessType = ObjectAccessType.ReadWriteInPreOp; 
						break; 
					}
						#endregion
						#region ReadReadWrite -> ReadReadWriteInPreOp
					case ObjectAccessType.ReadReadWrite:
					{
						accessType = ObjectAccessType.ReadReadWriteInPreOp;
						break;
					}
						#endregion
						#region ReadWriteWrite -> ReadWriteWriteInPreOp
					case ObjectAccessType.ReadWriteWrite:
					{
						accessType = ObjectAccessType.ReadWriteWriteInPreOp;
						break;
					}
						#endregion
						#region WriteOnly -> WriteOnlyInPreOp
					case ObjectAccessType.WriteOnly:
					{
						accessType = ObjectAccessType.WriteOnlyInPreOp;
						break;
					}
						#endregion
				}
			}
			#endregion
			#region else 'FALSE' assume so set accessType to equivalent for NOT in pre-op
			else
			{
				tempData.writeOnlyInPreOp = false;

				switch ( accessType )
				{
						#region ReadWriteInPreOp -> ReadWrite
					case ObjectAccessType.ReadWriteInPreOp: 
					{ 
						accessType = ObjectAccessType.ReadWrite; 
						break; 
					}
						#endregion
						#region ReadReadWriteInPreOp -> ReadReadWrite
					case ObjectAccessType.ReadReadWriteInPreOp:
					{
						accessType = ObjectAccessType.ReadReadWrite;
						break;
					}
						#endregion
						#region ReadWriteWriteInPreOp -> ReadWriteWrite
					case ObjectAccessType.ReadWriteWriteInPreOp:
					{
						accessType = ObjectAccessType.ReadWriteWrite;
						break;
					}
						#endregion
						#region WriteOnlyInPreOp -> WriteOnly
					case ObjectAccessType.WriteOnlyInPreOp:
					{
						accessType = ObjectAccessType.WriteOnly;
						break;
					}
						#endregion
				}
			}
			#endregion

			return ( accessType );
		}

		//-------------------------------------------------------------------------
		//  Name			: readBitSplit()
		//  Description     : Reads the bit split definition for the current object
		//					  being read from the EDS file and puts it into the
		//					  split structure.
		//  Parameters      : tempData - Structure which holds the definition of the 
		//						current object beind read from the EDS so far
		//  Used Variables  : None
		//  Preconditions   : A known Sevcon bit split section has been identified
		//					  in the current section of the EDS being read.
		//  Post-conditions : The split structure within the tempData structure is
		//					  populated with all the bit split definitions for this
		//					  object.
		//  Return value    : None
		//--------------------------------------------------------------------------
		/// <summary>Reads the bit split definition for this object, when an integer value is
		/// to be displayed to the user as if it were several different sub objects for ease
		/// of understanding when compacted in the device.</summary>
		/// <param name="tempData">Structure which holds the definition of the current object
		/// being read from the EDS so far.</param>
		private void readBitSplit( EDSObjectInfo tempData )
		{
			#region local variable declarations and initialisation
			string input;
			string upperCaseInput;
			int splitNumber = 0;
			int splitCount = -1;
			bool endOfSectionFound = false;
			bool validSplit = false;
			bool collatingEnums = false; //jude 031007 - need to do it this way NUMBERFORMAT is set to 2 for sepcial regrdless of number of enums
			string delimitedFormatList = "";
			string [] textSplit = null;
			#endregion

			#region check a valid split is defined and find the first split definition
			while ( ( input = readLine() ) != null )
			{
				string valueSubString = this.getvalueSubString(input);
				#region convert to upper case and remove any part line comments
//				removePartLineComments( input );
				upperCaseInput = input.ToUpper();
				#endregion

				#region if the SPLIT number definition is found then extract it and confirm it's valid
				if ( upperCaseInput.IndexOf( "SEVCONFIELD SPLIT" ) != -1 )
				{
					splitNumber = (int)sysInfo.convertToUint(valueSubString);
					splitCount++;

					if ( splitCount < tempData.split.Length )
					{
						tempData.split[ splitCount ].split = splitNumber;
					}

					if ( splitCount < tempData.split.Length )
					{
						validSplit = true;
						break;
					}
				}
					#endregion
					#region else if the end of this section is found then bit split not read in OK
				else if ( endOfSection( input ) == true )
				{// validSplit still false
					SystemInfo.errorSB.Append("Invalid Sevcon bit split definition. object index: "); 
					SystemInfo.errorSB.Append(tempData.indexNumber.ToString("X"));
					SystemInfo.errorSB.Append(", sub number 0x");
					if(tempData.subNumber<0)
					{
						SystemInfo.errorSB.Append(" header");
					}
					else
					{
						SystemInfo.errorSB.Append(tempData.subNumber.ToString("X").PadLeft(3, '0'));
					}

					break;
				}
				#endregion
			}
			#endregion

			if ( validSplit == true )
			{
				#region read subsequent split definitions until end of section or file is found
				while ( ( input = readLine() ) != null )
				{
					bool endOfEnumsFound = false;
					if(collatingEnums == true)
					{
						if((input.IndexOf("SEVCONFIELD SPLIT") != -1)
							|| (this.endOfSection(input) == true)
							|| (endOfEnumsFound == true) ) //we found something that didn't look like an enum
						{
							//complete enums actions
							collatingEnums = false;
							if ( delimitedFormatList.Length > 1 )
							{ //remove last ':'
								delimitedFormatList = delimitedFormatList.Remove( delimitedFormatList.Length - 1, 1 );
							}
							tempData.split[splitCount].formatList = delimitedFormatList;
						}
						else
						{
							#region convert to upper case and remove any comments
							removePartLineComments( input );
							upperCaseInput = input.ToUpper();
							#endregion
	
							#region else ignore any comments
							//else if ( aComment( upperCaseInput) == true )
							if ( aComment( upperCaseInput) == true )
							{
								// ignore any comments
							}
								#endregion
							#region else potential Sevcon replacement string for enumerated type
							else 
							{
								#region find SEVCONFIELD string and strip out
								if ( upperCaseInput.IndexOf( "SEVCONFIELD " ) != -1 )
								{
									input = input.Substring("SEVCONFIELD ".Length);
								}
								else
								{
									input = "";
								}
								#endregion

								#region split string, convert digit part then add other string to approp. part of list
								/* A valid format so split into two strings, one with xxxx (number)
									* and the other with the text descriptor.
									*/
								textSplit = input.Split( '=' );

								/* Convert number from hex text string to UInt16 and leave
									* descriptor as a text string.
									*/
								if ( textSplit.Length >= 2 )
								{  //judetemp some eunerateds ar enow very long eg EVAS - we need to be able to accomodate all 64bit numbers 
									//we can eithe rpad likeke this ans splita t knwon point or we can decide on a delimiter that is never used imn param name 
									//we could reuse ':' but this will need more processing later on- use the padding for now
									
									if(textSplit[0].IndexOf("UNITS") != -1)
									{
										#region units
										tempData.split[splitCount].units =  textSplit[1];
										#endregion units
									}
									else
									{
										#region enumerations
										bool isNum = true;
										if(	textSplit[0].ToUpper().IndexOf("0X") != -1)
										{ //hex 
											try
											{
												long val = System.Convert.ToInt64( textSplit[0].Trim(), 16);// + split[ 0 ].Substring(indexOf0x +2).PadLeft(16, '0');
											}
											catch
											{
												isNum = false;
											}
										}
										else
										{//base 10
											try
											{
												long val =System.Convert.ToInt64( textSplit[0].Trim());
											}
											catch
											{
												isNum = false;
											}
										}
										if(isNum == true)
										{
											delimitedFormatList = delimitedFormatList + input + ":";//split[ 1 ] + "_" + tempNumberString +":";
										}
										else
										{
												//mark the end of the enums here
												endOfEnumsFound = true;  //because we are now detecting enums rather than counting then then
											// any line we find that doesn't look like an enum should be taken as the end of the enums rather than an error
											//		SystemInfo.errorSB.Append("\nFailed to read all enumerated Sevcon Number formats. Faulty Text: ");
											//Do this here => next input line could be end of file
											if ( delimitedFormatList.Length > 1 )
											{ //remove last ':'
												delimitedFormatList = delimitedFormatList.Remove( delimitedFormatList.Length - 1, 1 );
											}
											tempData.split[splitCount].formatList = delimitedFormatList;

											//		SystemInfo.errorSB.Append(input);
										}
										#endregion enumerations
									}
								}
								#endregion
								continue;
							}
							#endregion

						}
					}
					string valueSubString = this.getvalueSubString(input);
					#region if end of section found then quit this loop
//					removePartLineComments( input );
					upperCaseInput = input.ToUpper();
					endOfSectionFound = endOfSection( input );

					if ( endOfSectionFound == true )
					{
						break;
					}
						#endregion
						#region else if a comment then ignore it
					else if ( aComment( upperCaseInput) == true )
					{
						// ignore
					}
						#endregion
						#region if start of a new split section check whether to quit or continue
					else if ( upperCaseInput.IndexOf( "SEVCONFIELD SPLIT" ) != -1 )
					{							
						splitNumber = (int)sysInfo.convertToUint(valueSubString);
						splitCount++;

						if ( splitCount >= tempData.split.Length )
						{
							// found more split definitions than expected but don't flag an error 
							endOfSectionFound = true;
							break;
						}
						else
						{
							tempData.split[ splitCount ].split = splitNumber;
						}
					}
						#endregion
						#region else if split parameter name defined then extract it
					else if ( upperCaseInput.IndexOf( "SEVCONFIELD PARAMETERNAME" ) != -1 )
					{
						tempData.split[ splitCount ].parameterName = input.Trim().Substring(input.IndexOf( "=" ) + 1);
					}
						#endregion
						#region else if split item bit mask defined then extract it
					else if (( upperCaseInput.IndexOf( "SEVCONFIELD BITMASK" ) != -1 ) && (input.IndexOf("=") != -1))
					{
						tempData.split[ splitCount ].bitMask = sysInfo.convertToLong( valueSubString);
					}
					else if (( upperCaseInput.IndexOf( "SEVCONFIELD UNITS" ) != -1 ) && (input.IndexOf("=") != -1))
					{
						tempData.split[ splitCount ].units = valueSubString;
					}
						#endregion
						#region else if split item bit shift defined then extract it
					else if ( upperCaseInput.IndexOf( "SEVCONFIELD BITSHIFT" ) != -1 )
					{
						tempData.split[ splitCount ].bitShift = (int)sysInfo.convertToUint(valueSubString);
					}
						#endregion
						#region else if split item low limit defined then extract it
					else if ( upperCaseInput.IndexOf( "SEVCONFIELD LOW_LIMIT" ) != -1 )
					{
						string valueSubStringMinusNodeID  = sysInfo.checkIfEDSParamValueContainsNodeID(valueSubString);
						if(valueSubStringMinusNodeID == valueSubString) //there was no $NODEID in parameter vlaue
						{
							tempData.split[ splitCount ].lowLimit = (int)sysInfo.convertToUint(valueSubString);
						}
						else
						{  //we need to add in the node ID to our parameter value;
							tempData.split[ splitCount ].lowLimit = (int)sysInfo.convertToUint(valueSubStringMinusNodeID) + this._nodeID;
						}
					}
						#endregion
						#region else if split item high limit defined then extract it
					else if ( upperCaseInput.IndexOf( "SEVCONFIELD HIGH_LIMIT" ) != -1 )
					{
						string valueSubStringMinusNodeID  = sysInfo.checkIfEDSParamValueContainsNodeID(valueSubString);
						if(valueSubStringMinusNodeID == valueSubString) //there was no $NODEID in parameter vlaue
						{
							tempData.split[ splitCount ].highLimit = (int)sysInfo.convertToUint(valueSubString);
						}
						else
						{  //we need to add in the node ID to our parameter value;
							tempData.split[ splitCount ].highLimit = (int)sysInfo.convertToUint(valueSubStringMinusNodeID) + this._nodeID;
						}
					}
						#endregion
						#region else if split item number format defined then extract it
					else if ( upperCaseInput.IndexOf( "SEVCONFIELD NUMBERFORMAT" ) != -1 )
					{
						tempData.split[ splitCount ].format = readSevconFormat( input);

						#region if Sevcon SPECIAL formatting
						/* If special format then need to read in enumerated text strings
								 * which are held in a sorted list (used instead of digits when
								 * displaying to the user.
								 */
						if ( tempData.split[ splitCount ].format == SevconNumberFormat.SPECIAL )
						{
							collatingEnums = true;
							endOfEnumsFound = false; //reset
							delimitedFormatList = ""; //reset
							continue;
							//Jude 031007 "NUMBERFORMAT=2" now jsut means that the follwoing lones ar eenumerate dNOT the nubmer of enumerations
							//so we hav eot count them until we hit one of end of section, end of file or another SPLIT
						}
						#endregion
					}
						#endregion
						#region else if split item units is defined then extract
					else if ( upperCaseInput.IndexOf( "SEVCONFIELD UNITS" ) != -1 )
					{
						tempData.split[ splitCount ].units = valueSubString;
					}
					#endregion

					#region if end of file or end of section then quit this while loop
					if ( ( input == null ) || ( endOfSectionFound == true ) )
					{
						break;
					}
					#endregion
				}
				#endregion

				#region resize split definitions if not as expected
				if ( ( splitCount + 1 ) != tempData.split.Length )
				{
					SystemInfo.errorSB.Append("\nIncorrect number of Sevcon split definitions for object: " );
					SystemInfo.errorSB.Append(tempData.indexNumber.ToString("X"));
					SystemInfo.errorSB.Append(", No found: ");
					SystemInfo.errorSB.Append(( splitCount + 1 ).ToString());
					SystemInfo.errorSB.Append(" No expected: ");
					SystemInfo.errorSB.Append(tempData.split.Length.ToString());
					//if we need to resixze arrays - then should consider using Arraylist - add then copy
					DataSplit [] newSplit = new DataSplit[ splitCount ];
					for ( int i = 0; i < newSplit.Length; i++ )
					{
						newSplit[ i ] = new DataSplit(tempData.split[ i ]);
					}
					tempData.split = new DataSplit[newSplit.Length];
					for(int i = 0;i<tempData.split.Length;i++)
					{
						tempData.split[i] = newSplit[ i ];
					}
				}
				#endregion
			}
		}


		//-------------------------------------------------------------------------
		//  Name			: getODIndexFromString()
		//  Description     : This function converts the object index from an ASCII
		//					  string format into an integer, which is returned.
		//					  Some string formatting to strip out any superfluous
		//					  characters is performed before the conversion.
		//  Parameters      : input - ASCII string expected to contain an object index
		//  Used Variables  : None
		//  Preconditions   : An ASCII string has been read from a file which is 
		//					  expected by DW to contain an object index in ASCII
		//					  hex string format.  This needs converted into an int.
		//  Post-conditions : index contains the integer equivalent of the input string.
		//  Return value    : index (contains int equiv or input of is -1 if failed)
		//--------------------------------------------------------------------------
		///<summary>Converts the object index from ASCII string format into an integer.</summary>
		/// <param name="input">ASCII string expected to contain an object index</param>
		/// <returns>index (contains int equiv or input of is -1 if failed)</returns>
		private int getODIndexFromString( string input )
		{
			#region local variable declarations
			int index = -1;
			int	startOfSub = -1;
			#endregion

			#region strip superflous chars from string to leave part representing number
			input = input.ToUpper();
			input = input.TrimStart( '[' );
			input = input.TrimEnd( ']' );
			input = input.TrimStart();
			input = input.TrimEnd();
			#endregion

			#region strip of SUB string and sub number to leave index if in this line string
			startOfSub = input.IndexOf( "SUB" );

			if ( startOfSub != -1 )
			{
				input = input.Substring( 0, startOfSub );
			}
			#endregion

			#region convert string representing index into an integer
			try
			{
				index = (int)System.Convert.ToUInt32( input, 16 );
			}
			catch ( Exception )
			{
			}
			#endregion

			return ( index );
		}

		//-------------------------------------------------------------------------
		//  Name			: getODSubNoFromString()
		//  Description     : This function converts the object subindex from an ASCII
		//					  string format into an integer, which is returned.
		//					  Some string formatting to strip out any superfluous
		//					  characters is performed before the conversion.
		//  Parameters      : input - ASCII string expected to contain an object subindex
		//  Used Variables  : None
		//  Preconditions   : An ASCII string has been read from a file which is 
		//					  expected by DW to contain an object sub index in ASCII
		//					  hex string format.  This needs converted into an int.
		//  Post-conditions : sub contains the integer equivalent of the input string.
		//  Return value    : sub (contains int equiv or input of is -1 if failed)
		//--------------------------------------------------------------------------
		///<summary>Converts the object sub index from ASCII string format into an integer.</summary>
		/// <param name="input">ASCII string expected to contain an object subindex</param>
		/// <returns>sub (contains int equiv or input of is -1 if failed)</returns>
		private int getODSubNoFromString( string input )
		{
			#region local variable declarations
			int sub = -1;
			int startOfSub;
			#endregion

			#region strip superflous chars from string to leave part representing number
			input = input.ToUpper();
			input = input.TrimStart( '[' );
			input = input.TrimEnd( ']' );
			input = input.TrimStart();
			input = input.TrimEnd();
			#endregion

			#region check if this input line string contains a sub number
			startOfSub = input.IndexOf( "SUB" );
			#endregion

			#region if this is a sub object, convert string representing sub into an integer
			if ( startOfSub != -1 )
			{
				// extract the string representing the sub number from the string
				input = input.Substring( startOfSub + 3, input.Length - startOfSub - 3 );

				#region convert string representing sub number into an integer
				try
				{
					sub = (int)System.Convert.ToUInt32( input, 16 );
				}
				catch ( Exception )
				{
				}
				#endregion
			}
			#endregion

			return ( sub );
		}

		/// <summary>
		/// For parameter strings that cannot contain "$NODEID"
		/// </summary>
		/// <param name="input"></param>
		/// <returns></returns>
		private string getvalueSubString(string input )
		{
			string valueSubString = "";
			int equalsIndex = input.IndexOf("=") + 1; //add one to move to first character after the index
			if((equalsIndex >0 ) && (equalsIndex <input.Length))
			{
				valueSubString = input.Substring(equalsIndex).Trim();
			}
			removePartLineComments(valueSubString);
			return valueSubString;
		}


		//-------------------------------------------------------------------------
		//  Name			: writeParameterValue()
		//  Description     : This function converts the current value of the object of
		//					  array element, item, into a string and writes the
		//					  parameter string to the DCF file currently open for writing.
		//					  Conversion to an ASCII string is dependent on the object's
		//					  underlaying data type.
		//  Parameters      : data - object dictionary containing the parameter value
		//							 to be written to the DCF file stream
		//					  item - 2 dimensional element to indicate which ODItemData
		//							 in data[][] contains the parameter value needed
		//  Used Variables  : DCFsw - DCF file stream writer
		//  Preconditions   : The DCF file has been opened for writing, the EDS for the
		//					  device has been found and read to construct the object
		//					  dictionary, the entire object dictionary of this device
		//				      has been read, the header sections of the DCF file have
		//					  been written and this object's section has been found 
		//					  in the EDS file and has already been copied into the DCF.
		//  Post-conditions : The DCF file stream writer has the current value of
		//					  array element item within data[][] written to the DCF file.
		//  Return value    : None
		//--------------------------------------------------------------------------
		///<summary>Writes the current value of the data array object to the opened DCF file.</summary>
		/// <param name="data">object dictionary containing the parameter value to be written
		/// to the DCF file stream</param>
		/// <param name="item">2 dimensional element to indicate which ODItemData in data[][]
		/// contains the parameter value needed</param>
		private void writeParameterValue( ODItemData odSub, ObjDictItem odItem)
		{
			#region if this object or sub isn't read on a scan then return as no parameter value needs written
			if ( ( odSub.objFlags & SCCorpStyle.RefuseReadOnScan )== SCCorpStyle.RefuseReadOnScan )
			{
				return;
			}
			if(odSub.accessType == ObjectAccessType.WriteOnly)
			{
				return; //If the item is write only then our 'value' is just a DW default.
			}
			if((odSub.subNumber == -1) && (odSub.format != SevconNumberFormat.BIT_SPLIT))
			{
				DCFsw.WriteLine("");						// force a blank line between objs & subs in a DCF
				return;
			}
//			if((odSub.subNumber == 0) && (odSub.isNumItems == true))
//			{
//				ArrayList bitsplits = new ArrayList();
//				int realNumSubs = 0;
//				foreach(ODItemData odTestSub in odItem.odItemSubs)
//				{
//					if(odTestSub.subNumber>0)
//					{
//						if(odTestSub.bitSplit == null)
//						{
//							realNumSubs++;
//						}
//						else
//						{
//							if(bitsplits.Contains(odTestSub.bitSplit.realSubNo) == false)
//							{
//								bitsplits.Add(odTestSub.bitSplit.realSubNo);
//							}
//						}
//					}
//				}
//				realNumSubs += bitsplits.Count;
//				if(odSub.format == SevconNumberFormat.BASE16)
//				{
//					DCFsw.WriteLine( "ParameterValue=0x" + realNumSubs.ToString( "X" ) );
//				}
//				else
//				{
//					DCFsw.WriteLine( "ParameterValue=" + realNumSubs.ToString() );
//				}
//				return;
//			}
			#endregion
			#region else write parameter value to DCF file dependent on data type
			switch (odSub.displayType )
			{
					#region write visible string to DCF
				case CANopenDataType.VISIBLE_STRING:
				{
					DCFsw.WriteLine( "ParameterValue=" + odSub.currentValueString );

					// force a blank line between objs & subs in a DCF if item is a null 
					if (odSub.currentValueString == null )
					{
						DCFsw.WriteLine("");
					}
					break;
				}
					#endregion			
					#region write unsigned integer types to DCF (1/8/16/24/32/40/48/56/64 bits)
				case CANopenDataType.BOOLEAN:
				case CANopenDataType.UNSIGNED8:
				case CANopenDataType.UNSIGNED16:
				case CANopenDataType.UNSIGNED24:
				case CANopenDataType.UNSIGNED32:
				case CANopenDataType.UNSIGNED40:
				case CANopenDataType.UNSIGNED48:
				case CANopenDataType.UNSIGNED56:
				case CANopenDataType.UNSIGNED64:
				{
					if((odSub.subNumber == -1) && ( odSub.format == SevconNumberFormat.BIT_SPLIT))
					{ //bitsplit whole odItem
						long cumValue = 0;
						foreach(ODItemData bsSub in odItem.odItemSubs)
						{ //whole item is part of same bit split
							if( bsSub.bitSplit != null)
							{
								cumValue += (bsSub.currentValue <<bsSub.bitSplit.bitShift);
							}
						}
						DCFsw.WriteLine( "ParameterValue=0x" + cumValue.ToString( "X" ) );
					}
					else if((odSub.subNumber != -1) && (odSub.bitSplit != null))
					{
						//bit split subs 
						long cumValue = 0;
						foreach(ODItemData bsSub in odItem.odItemSubs)
						{
							if((bsSub.bitSplit!= null) && (bsSub.bitSplit.realSubNo ==odSub.bitSplit.realSubNo))
							{
								cumValue += (bsSub.currentValue <<bsSub.bitSplit.bitShift);
							}
						}
						DCFsw.WriteLine( "ParameterValue=0x" + cumValue.ToString( "X" ) );
					}
					else
					{
						if(odSub.format == SevconNumberFormat.BASE16)
						{
							DCFsw.WriteLine( "ParameterValue=0x" + odSub.currentValue.ToString( "X" ) );
						}
						else
						{
							DCFsw.WriteLine( "ParameterValue=" + odSub.currentValue.ToString() );
						}
					}
					break;
				}
					#endregion
					#region write signed integer 8 bit to DCF
				case CANopenDataType.INTEGER8:	// limit to correct no. of bits (in case negative)
				{
					long temp = odSub.currentValue & 0xff;
					if(odSub.format == SevconNumberFormat.BASE10)
					{
						DCFsw.WriteLine( "ParameterValue=" + temp.ToString( ) );
					}
					else //Base 16
					{
						DCFsw.WriteLine( "ParameterValue=0x" + temp.ToString( "X" ) );
					}
					break;
				}
					#endregion
					#region write signed integer 16 bit to DCF
				case CANopenDataType.INTEGER16:	// limit to correct no. of bits (in case negative)
				{
					long temp = odSub.currentValue & 0xffff;
					if(odSub.format == SevconNumberFormat.BASE10)
					{
						DCFsw.WriteLine( "ParameterValue=" + temp.ToString( ) );
					}
					else //Base 16
					{
						DCFsw.WriteLine( "ParameterValue=0x" + temp.ToString( "X" ) );
					}
					break;
				}
					#endregion
					#region  write signed integer 24 bit to DCF
				case CANopenDataType.INTEGER24:		// limit to correct no. of bits (in case negative)
				{
					long temp = odSub.currentValue & 0xffffff;
					if(odSub.format == SevconNumberFormat.BASE10)
					{
						DCFsw.WriteLine( "ParameterValue=" + temp.ToString( ) );
					}
					else //Base 16
					{
						DCFsw.WriteLine( "ParameterValue=0x" + temp.ToString( "X" ) );
					}
					break;
				}
					#endregion
					#region write signed integer 32 bit to DCF
				case CANopenDataType.INTEGER32:	// limit to correct no. of bits (in case negative)
				{
					long temp = odSub.currentValue & 0xffffffff;
					if(odSub.format == SevconNumberFormat.BASE10)
					{
						DCFsw.WriteLine( "ParameterValue=" + temp.ToString( ) );
					}
					else //Base 16
					{
						DCFsw.WriteLine( "ParameterValue=0x" + temp.ToString( "X" ) );
					}
					break;
				}
					#endregion
					#region  write signed integer 40 bit to DCF
				case CANopenDataType.INTEGER40:	// limit to correct no. of bits (in case negative)
				{
					long temp = odSub.currentValue & 0xffffffffff;
					if(odSub.format == SevconNumberFormat.BASE10)
					{
						DCFsw.WriteLine( "ParameterValue=" + temp.ToString( ) );
					}
					else //Base 16
					{
						DCFsw.WriteLine( "ParameterValue=0x" + temp.ToString( "X" ) );
					}
					break;
				}
					#endregion
					#region write signed integer 48 bit to DCF
				case CANopenDataType.INTEGER48:	// limit to correct no. of bits (in case negative)
				{
					long temp = odSub.currentValue & 0xffffffffffff;
					if(odSub.format == SevconNumberFormat.BASE10)
					{
						DCFsw.WriteLine( "ParameterValue=" + temp.ToString( ) );
					}
					else //Base 16
					{
						DCFsw.WriteLine( "ParameterValue=0x" + temp.ToString( "X" ) );
					}
					break;
				}
					#endregion
					#region  write signed integer 56 bit to DCF
				case CANopenDataType.INTEGER56:	// limit to correct no. of bits (in case negative)
				{
					long temp = odSub.currentValue & 0xffffffffffffff;
					if(odSub.format == SevconNumberFormat.BASE10)
					{
						DCFsw.WriteLine( "ParameterValue=" + temp.ToString( ) );
					}
					else //Base 16
					{
						DCFsw.WriteLine( "ParameterValue=0x" + temp.ToString( "X" ) );
					}
					break;
				}
					#endregion
					#region write signed integer 64 bit to DCF
				case CANopenDataType.INTEGER64:
				{
					if(odSub.format == SevconNumberFormat.BASE10)
					{
						DCFsw.WriteLine( "ParameterValue=" + odSub.currentValue.ToString( ) );
					}
					else //Base 16
					{
						DCFsw.WriteLine( "ParameterValue=0x" + odSub.currentValue.ToString( "X" ) );
					}

					break;
				}
					#endregion
					#region write domain to DCF (and to domain file)
				case CANopenDataType.DOMAIN:
				{
					if ( odSub.currentValueDomain != null )
					{
						DCFsw.WriteLine( "UploadFile=" + domainFilename );
						odSub.objectName = odSub.objectName;
						writeDomainObject( odSub );
					}
					else
					{
						DCFsw.WriteLine( "UploadFile=" );
					}
					break;
				}
					#endregion
					#region writem real32 and real64 to DCF
				case CANopenDataType.REAL32:
				{
					if ( odSub.real32 != null )
					{
                        //Jude DR000234 Apply InvariantCulture to all convertsions between strings and floats/doubles/reals
                        DCFsw.WriteLine("ParameterValue=" + odSub.real32.currentValue.ToString(CultureInfo.InvariantCulture.NumberFormat));
					}
					break;
				}
				case CANopenDataType.REAL64:
				{
					if ( odSub.real64 != null )
					{
                        //Jude DR000234 Apply InvariantCulture to all convertsions between strings and floats/doubles/reals
                        DCFsw.WriteLine("ParameterValue=" + odSub.real64.currentValue.ToString(CultureInfo.InvariantCulture.NumberFormat));
                    }
					break;
				}
					#endregion
					#region don't write DriveWizard unhandled data types to DCF file
				case CANopenDataType.ARRAY:
				case CANopenDataType.RECORD:
				case CANopenDataType.IDENTITY:
				case CANopenDataType.OCTET_STRING:
				case CANopenDataType.UNICODE_STRING:
				case CANopenDataType.PDO_COMMUNICATION_PARAMETER:
				case CANopenDataType.PDO_MAPPING:
				case CANopenDataType.SDO_PARAMETER:
				case CANopenDataType.TIME_DIFFERENCE:
				case CANopenDataType.TIME_OF_DAY:
				case CANopenDataType.NULL:
				default:
				{
					break;
				}
					#endregion
			}
			#endregion
		}

		//-------------------------------------------------------------------------
		//  Name			: writeDomainObject()
		//  Description     : This function takes a domain object which is defined in
		//					  data and converts this array of bytes into ASCII hex 
		//					  and writes this to the domain file associated with
		//					  the DCF.  There is certain object header information
		//					  also written so that it can be reconstructed when
		//					  the DCF file & associated domain file are read back in.
		//  Parameters      : data - data dictionary item containing a currentValue
		//							 which is of domain data type.
		//  Used Variables  : swDomain - stream writer for the DCF domain file
		//  Preconditions   : The DCF file has been opened for writing, the EDS for the
		//					  device has been found and read to construct the object
		//					  dictionary, the entire object dictionary of this device
		//				      has been read, the header sections of the DCF file have
		//					  been written and this object's section has been found 
		//					  in the EDS file and has already been copied into the DCF.
		//				      The current data to be written to the DCF file has already
		//					  been found to be of the underlaying domain data type.
		//  Post-conditions : The domain value of data has been written to the DCF domain
		//					  file stream writer once converted to ASCII hex. Section
		//					  information is also written for ease of readinng back in.
		//  Return value    : fbc - success or indicates a failure reason
		//--------------------------------------------------------------------------
		///<summary>Writes the current values of the domain object in data to the opened DCF domain file.</summary>
		/// <param name="data">data dictionary item containing a currentValue which is of domain
		/// data type</param>
		/// <returns>feedback indicates success or gives a failure reason</returns>
		private DIFeedbackCode writeDomainObject( ODItemData odSub )
		{
			#region local variable declarations
			DIFeedbackCode fbc = DIFeedbackCode.DIGeneralFailure;
			//int numLines;
			#endregion

			#region write domain object header information
			swDomain.WriteLine();
			swDomain.WriteLine( ";" + "[" + odSub.indexNumber.ToString( "X" ) + "sub" + odSub.subNumber.ToString( "X" ) +"]" );
			if(odSub.CANnode.manufacturer == Manufacturer.SEVCON)
			{
				swDomain.WriteLine( ";SEVCONFIELD SECTION=" + odSub.sectionTypeString );
                swDomain.WriteLine( ";SEVCONFIELD OBJECT=" + odSub.objectNameString );
			}
			#endregion

			#region write data bytes in ASCII hex, setting out as 16 bytes in a line, space delimited
            //DR38000260 - commented out code removed
			StringBuilder strBld = new StringBuilder();	
			strBld.Append("\n\n"); //start on new line
			for(int domainPtr = 0;domainPtr<odSub.currentValueDomain.Length;domainPtr++)
			{
				strBld.Append("0x");
				if(odSub.currentValueDomain[domainPtr].ToString( "X" ).Length <2)
				{
					strBld.Append("0");
				}
				strBld.Append(odSub.currentValueDomain[domainPtr].ToString( "X" ));
				if((domainPtr >0) && ((domainPtr +1) % 16 == 0))
				{
					strBld.Append("\n");
				}
				else if(domainPtr <= (odSub.currentValueDomain.Length -1))//don't put a comma after the last one
				{
					strBld.Append(" , ");
				}
			}
			swDomain.Write(strBld.ToString());
            //DR38000260 - commented out code removed
            swDomain.Flush();

			#endregion

			#region write end of object footer information
			swDomain.WriteLine( "[END_SECTION]" );
			swDomain.Flush();
			#endregion

			return ( fbc );
		}

		//-------------------------------------------------------------------------
		//  Name			: writeObjectHeaderSection()
		//  Description     : Writes the object section header to the DCF file
		//					  being generated ie the MANDATORY, OPTIONAL or
		//					  MANUFACTURER section which lists how many objects
		//					  and which indices will be defined in the file.
		//  Parameters      : input - last string read from the EDS file
		//					  EDS - EDS being used to generate this DCF
		//					  noOfObjects - number of valid objects for each object section
		//					  objectList - list of valid object indices for each object section
		//  Used Variables  : None
		//  Preconditions   : noOfObjects and objectList have already been calculated and
		//					  the DCF file being generated is at the correct point to
		//					  write one of the three section headers
		//  Post-conditions : The relevant object section header has been written 
		//					  to the DCF file.
		//  Return value    : None
		//--------------------------------------------------------------------------
		/// <summary>Writes the relevant object section header to the DCF file already open.</summary>
		/// <param name="input">last string read from the EDS file</param>
		/// <param name="EDS">EDS being used to generate this DCF</param>
		/// <param name="noOfObjects">number of valid objects for each object section</param>
		/// <param name="objectList">list of valid object indices for each object section</param>
		internal void writeObjectHeaderSection( string objectListTitleLine, ArrayList itemsForThisSection)
		{
			// write line read in [MANDATORYOBJECTS] etc to DCF file as was in EDS
			DCFsw.WriteLine( objectListTitleLine );
			#region if a valid section, write all the valid objects to the DCF file
			DCFsw.WriteLine( "SupportedObjects=" + itemsForThisSection.Count.ToString() );
			int count = 1;
				foreach(int odIndex in itemsForThisSection)	
				{
					DCFsw.WriteLine( count.ToString() + "=0x" + odIndex.ToString( "x" ) );
					count++;
				}
				DCFsw.WriteLine( "" );
				DCFsw.Flush();
			#endregion
		}


		#endregion

		#region methods for writing all sections to a DCF file
		//-------------------------------------------------------------------------
		//  Name			: writeFileInfoSection(string EDSorDCFfilepath)
		//  Description     : This function writes the [FileInfo] section of the
		//					  DCF file to the currently opened DCF file (with
		//					  write access).  Since DW creates the DCF file,
		//					  it assumes that the file version is version 1,
		//					  the revision is 0 & the DCF version is 1.0.
		//  Parameters      : EDS - Class instance of EDSorDCF which this DCF is
		//							to be based on (ie used to construct the OD
		//							of the node found on the system which's OD
		//						    current status has to be saved to DCF file).
		//  Used Variables  : DCFfilename - name of the file being written (DCF)
		//					  EDSfilename - name of the EDS file OD is based upon
		//  Preconditions   : The system connected to DW has been found and EDS files
		//					  have been found which match the device info which has 
		//					  been read to reconstruct this node's OD.  A node
		//					  on the system has been selected to save it's OD's
		//					  current values into a DCF file, the entire OD of this
		//					  node has already been read to obtain the current values,
		//					  the DCF filename has been entered/selected by the
		//					  user and this file has successfully been opened for
		//					  writing.
		//  Post-conditions : The DCF file of DCFfilename which is currently open
		//					  for writing has been written with the commissioning
		//					  section data, reflecting the selected node on the
		//					  system's current status (ie baud rate, node ID etc)
		//  Return value    : fbc - success or indicates a failure reason
		//--------------------------------------------------------------------------
		///<summary>Writes the FileInfo section to the DCF file currently being generated.</summary>
		/// <param name="EDS">Class instance of EDSorDCF which this DCF is to be based on
		/// (ie used to construct the OD of the node found on the system which's OD current
		/// status has to be saved to DCF file)</param>
		/// <returns>feedback indicates success or gives a failure reason</returns>
		/// 
		public void writeDCFFileInfoSection(DCFNode dcfNode)
		{
			#region write FileInfo section with default data descriptions
			DCFsw.WriteLine( "[FileInfo]" );
			if(dcfNode.includeChecksum == true)
			{
				//dcf
			}
			DCFsw.WriteLine( "FileName=" + dcfNode.EDSorDCFfilepath );
			DCFsw.WriteLine( "FileVersion=" + dcfNode.EDS_DCF.FileInfo.fileVersion);
			DCFsw.WriteLine( "FileRevision=" + dcfNode.EDS_DCF.FileInfo.fileRevision);
			DCFsw.WriteLine( "DCFVersion=1.0");  //judetemp - out to be a parameter
			string description = "";
			if(dcfNode.vendorID == SCCorpStyle.SevconID)
			{
				description = "Sevcon DCF file";  //allow user to enter descrption?? judetemp
			}
			DCFsw.WriteLine( "Description=" + description );
            //Jude DR000234 Apply InvariantCulture to convertsions as required
            string[] CultIndepDateTime = DateTime.Now.GetDateTimeFormats(System.Globalization.CultureInfo.InvariantCulture.DateTimeFormat);
            DCFsw.WriteLine("CreationTime=" + CultIndepDateTime[0x11]);
            //the invarian tculture does not give us an excat  
            //match for the CANopen spec so we need to chnage the seperator
            string moddedDate = CultIndepDateTime[0].Replace("/", "-");
            DCFsw.WriteLine("CreationDate=" + moddedDate);
            DCFsw.WriteLine("CreatedBy=Tech/Ops SEVCON Ltd");
            DCFsw.WriteLine("ModificationTime=" + CultIndepDateTime[0x11]);
            DCFsw.WriteLine("ModificationDate=" + moddedDate);
            DCFsw.WriteLine("ModifiedBy=Tech/Ops SEVCON Ltd");
            DCFsw.WriteLine();
			#endregion
		}

		//-------------------------------------------------------------------------
		//  Name			: writeDCFDeviceInfoSection()
		//  Description     : This function writes the [DeviceInfo] section of the
		//					  DCF file to the currently opened DCF file (with
		//					  write access).  Since DW must already have found an
		//					  EDS file to define the selected node (who's current
		//					  values are being written to the DCF file), the 
		//					  [DeviceInfo] section of the related EDS file is simply
		//					  copied & written to the DCF file.
		//  Parameters      : EDS - Class instance of EDSorDCF which this DCF is
		//							to be based on (ie used to construct the OD
		//							of the node found on the system which's OD
		//						    current status has to be saved to DCF file).
		//  Used Variables  : EDS.DCFsw - DCF file stream writer
		//  Preconditions   : The system connected to DW has been found and EDS files
		//					  have been found which match the device info which has 
		//					  been read to reconstruct this node's OD.  A node
		//					  on the system has been selected to save it's OD's
		//					  current values into a DCF file, the entire OD of this
		//					  node has already been read to obtain the current values,
		//					  the DCF filename has been entered/selected by the
		//					  user and this file has successfully been opened for
		//					  writing.
		//  Post-conditions : The DCF file of DCFfilename which is currently open
		//					  for writing has been written with the device info
		//					  section data, reflecting the selected node on the
		//					  system's current status.
		//  Return value    : fbc - success or indicates a failure reason
		//--------------------------------------------------------------------------
		///<summary>Writes the DeviceInfo section to the DCF file currently being generated.</summary>
		/// <param name="EDS">Class instance of EDSorDCF which this DCF is to be based on
		/// (ie used to construct the OD of the node found on the system which's OD current
		/// status has to be saved to DCF file)</param>
		/// <returns>feedback indicates success or gives a failure reason</returns>
		public void writeDCFDeviceInfoSection( DCFNode dcfNode)
		{
			#region write the DeviceInfo section to DCF file
			DCFsw.WriteLine("[DeviceInfo]" );
			DCFsw.WriteLine("VendorName=" +		dcfNode.EDS_DCF.EDSdeviceInfo.vendorName);
			DCFsw.WriteLine("ProductName=" +		dcfNode.EDS_DCF.EDSdeviceInfo.productName);
			DCFsw.WriteLine("OrderCode=" +		dcfNode.EDS_DCF.EDSdeviceInfo.orderCode);
			DCFsw.WriteLine("VendorNumber=0x" +		dcfNode.vendorID.ToString("X").PadLeft(8,'0'));
			DCFsw.WriteLine("ProductNumber=0x" + dcfNode.productCode.ToString("X").PadLeft(8, '0'));
			DCFsw.WriteLine("RevisionNumber=0x" +	dcfNode.revisionNumber.ToString("X").PadLeft(8,'0'));
			DCFsw.WriteLine("BaudRate_10=" +		( System.Convert.ToUInt16(dcfNode.EDS_DCF.EDSdeviceInfo.BaudRate_10)).ToString());
			DCFsw.WriteLine("BaudRate_20=" +		( System.Convert.ToUInt16(dcfNode.EDS_DCF.EDSdeviceInfo.BaudRate_20)).ToString());
			DCFsw.WriteLine("BaudRate_50=" +		( System.Convert.ToUInt16(dcfNode.EDS_DCF.EDSdeviceInfo.BaudRate_50)).ToString());
			DCFsw.WriteLine("BaudRate_125=" +		( System.Convert.ToUInt16(dcfNode.EDS_DCF.EDSdeviceInfo.BaudRate_125)).ToString());
			DCFsw.WriteLine("BaudRate_250=" +		( System.Convert.ToUInt16(dcfNode.EDS_DCF.EDSdeviceInfo.BaudRate_250)).ToString());
			DCFsw.WriteLine("BaudRate_500=" +		( System.Convert.ToUInt16(dcfNode.EDS_DCF.EDSdeviceInfo.BaudRate_500)).ToString());
			DCFsw.WriteLine("BaudRate_800=" +		( System.Convert.ToUInt16(dcfNode.EDS_DCF.EDSdeviceInfo.BaudRate_800)).ToString());
			DCFsw.WriteLine("BaudRate_1000=" +		( System.Convert.ToUInt16(dcfNode.EDS_DCF.EDSdeviceInfo.BaudRate_1000)).ToString());
			DCFsw.WriteLine("SimpleBootUpMaster="+	( System.Convert.ToUInt16(dcfNode.EDS_DCF.EDSdeviceInfo.SimpleBootUpMaster)).ToString());
			DCFsw.WriteLine("SimpleBootUpSlave=" +	( System.Convert.ToUInt16(dcfNode.EDS_DCF.EDSdeviceInfo.SimpleBootUpSlave)).ToString());
			DCFsw.WriteLine("Granularity=" +		dcfNode.EDS_DCF.EDSdeviceInfo.Granularity.ToString());
			DCFsw.WriteLine("GroupMessaging=" +		(System.Convert.ToUInt16(dcfNode.EDS_DCF.EDSdeviceInfo.GroupMessaging)).ToString());
			DCFsw.WriteLine("DynamicChannelsSupported=" + (System.Convert.ToUInt16(dcfNode.EDS_DCF.EDSdeviceInfo.DynamicChannelsSupported)).ToString());
			DCFsw.WriteLine("NrOfRXPDO=" +			dcfNode.EDS_DCF.EDSdeviceInfo.NrOfRXPDO.ToString());
			DCFsw.WriteLine("NrOfTXPDO=" +			dcfNode.EDS_DCF.EDSdeviceInfo.NrOfTXPDO.ToString());
			DCFsw.WriteLine("LSS_Supported=" +		( System.Convert.ToUInt16(dcfNode.EDS_DCF.EDSdeviceInfo.LSS_Supported)).ToString());
			DCFsw.WriteLine();
			#endregion write the DeviceInfo section to DCF file
		}
		//-------------------------------------------------------------------------
		//  Name			: writeDCFCommissioningInfoSection()
		//  Description     : This function writes the [DeviceCommissioning] section
		//					  to the DCF file which has already been opened for
		//					  writing. Only the node ID and the baud rate are written
		//					  to this section, defaults being used for all other items
		//					  since Sevcon does not use these yet. 
		//  Parameters      : nodeID - ID of the node which is having it's current state
		//							of the OD written to the DCF file
		//					  baud - baud rate of the system connected to DW via the
		//							 USB-CAN adapter.
		//  Used Variables  : DCFsw - DCF file stream writer
		//  Preconditions   : The system connected to DW has been found and EDS files
		//					  have been found which match the device info which has 
		//					  been read to reconstruct this node's OD.  A node
		//					  on the system has been selected to save it's OD's
		//					  current values into a DCF file, the entire OD of this
		//					  node has already been read to obtain the current values,
		//					  the DCF filename has been entered/selected by the
		//					  user and this file has successfully been opened for
		//					  writing.
		//  Post-conditions : The DCF file of DCFfilename which is currently open
		//					  for writing has been written with the commissioning
		//					  section data, reflecting the selected node on the
		//					  system's current status (ie baud rate, node ID etc)
		//  Return value    : fbc - success or indicates a failure reason
		//--------------------------------------------------------------------------
		///<summary>Writes the DCFCommissioningInfo section to the DCF file currently being generated.</summary>
		/// <param name="nodeID">ID of the node which is having it's current state of the OD written 
		/// to the DCF file</param>
		/// <param name="baud">baud rate of the system connected to DW via the USB-CAN adapter</param>
		/// <returns>feedback indicates success or gives a failure reason</returns>
		public void writeDCFCommissioningInfoSection( DCFNode dcfNode, BaudRate baud )
		{
			#region write DeviceCommissioning section
			DCFsw.WriteLine( "[DeviceComissioning]" );
			DCFsw.WriteLine( "NodeID=0x" + dcfNode.nodeID.ToString( "X" ) );
			DCFsw.WriteLine( "NodeName=" );
			DCFsw.WriteLine( "Baudrate=" + baudRateStrings[(int) baud]);//getBaudStringFromEnum( baud ) );
			DCFsw.WriteLine( "NetNumber=" );
			DCFsw.WriteLine( "NetworkName=" );
			DCFsw.WriteLine( "CANopenManager=" );
			DCFsw.WriteLine( "LSS_SerialNumber=" );
			DCFsw.WriteLine();
			#endregion
		}


		internal void writeDCFItemAndSubs(int odIndexToWrite, string filepath, byte nodeAccessLevel, nodeInfo dcfNode)
		{
			bool writeInPreOpFlag = false;
			ArrayList realSubsAlreadyWritten = new ArrayList();
			ObjDictItem odItem  = dcfNode.getODItemAndSubs(odIndexToWrite);
			if(odItem == null)
			{
				return; // B&B should never happen user feedback will be inserted by getODItemAndSubs(
			}
			foreach(ODItemData odSub in odItem.odItemSubs)
			{
				if(odItem.odItemSubs.IndexOf(odSub) == 0)  
				{
					#region single sub item (normal or BitSplit)  or header row
					this.DCFsw.WriteLine("[" + odIndexToWrite.ToString("X").PadLeft(4, '0') +"]"); //eg [1018]

					if(odItem.odItemSubs.Count == 1) 
					{ 
						#region true single sub item
						this.DCFsw.WriteLine("ParameterName=" + odSub.parameterName);
						this.writeObjectTypeLine(odSub.objectType);
						this.writeDataTypeLine(odSub.dataType);
						this.writeAccessTypeLine(odSub.accessType, out writeInPreOpFlag); 
						this.writeLowandHighLimitLines(odSub);
						this.writePDOMappingLine(odSub.PDOmappable);
						writeObjFlagsLine(odSub);
						this.writeDCFDefaultValueLine(odSub);
						this.writeParameterValue(odSub, odItem);  //Jude 021007
						writeSevconObjectVerisonLine(odSub.objectVersion);
							
						if(dcfNode.manufacturer == Manufacturer.SEVCON)
						{
							this.writeDCFSevconAccessLevel(odSub.accessLevel);
							writeDCFSevconScaling(odSub.scaling);
							writeDCFSevconUnits(odSub.units);
							writeDCFSectionAndObjectFields(odSub);
							writeDCfEEPROMString(odSub);
							writeDCFToolTip(odSub);
							if (odSub.format == SevconNumberFormat.SPECIAL)
							{
								if(odSub.format == SevconNumberFormat.SPECIAL)
								{
									writeDCFSevconNumber_Format(odSub);
								}
							}
							else if(odSub.format == SevconNumberFormat.BASE16)
							{
								this.DCFsw.WriteLine(";SEVCONFIELD NUMBER_FORMAT=BASE16");
							}
							this.writeDCFSevconWriteInPreOp(writeInPreOpFlag);
							this.writeDCFSevocnCommstimeout(odSub.commsTimeout);
							writeDCFSevconMasterOnly(odSub);
						}
						#endregion True single sub item
					}
					else
					{
						if(odSub.format == SevconNumberFormat.BIT_SPLIT)  //must be Sevcon
						{ 
							#region single sub item bitsplit into multiple pseudo subs
							this.DCFsw.WriteLine("ParameterName=" + odSub.parameterName);
							this.writeObjectTypeLine(odSub.objectType);
							this.writeDataTypeLine(odSub.dataType);
							if(odItem.odItemSubs.Count>=2)
							{
								ObjectAccessType acc = ((ODItemData) odItem.odItemSubs[2]).accessType;
								this.writeAccessTypeLine(acc, out writeInPreOpFlag);
							}
							this.writeLowandHighLimitLines(odSub);
							this.writePDOMappingLine(odSub.PDOmappable);
							writeObjFlagsLine(odSub);
							writeDCFDefaultValueLine(odSub);
							this.writeParameterValue(odSub,odItem); //Jude021007
							this.writeSevconObjectVerisonLine(odSub.objectVersion);
							this.writeDCFSevconAccessLevel(odSub.accessLevel);
							writeDCFSectionAndObjectFields(odSub);
							writeDCfEEPROMString(odSub);
							writeDCFToolTip(odSub);
							writeDCFSevconScaling(odSub.scaling);
							this.writeDCFSevconWriteInPreOp(writeInPreOpFlag);
							this.writeDCFSevocnCommstimeout(odSub.commsTimeout);
							writeDCFSevconMasterOnly(odSub);
							writeSingleSubBitSplitToDCF(odSub, odItem, writeInPreOpFlag);
							this.DCFsw.WriteLine();  //end with blank line
							break; //we have handled all 'subs' in this item - break to next item
							#endregion single sub item bitsplit into multiple pseudo subs
						}
						else
						{
							#region normal Item header
							this.DCFsw.WriteLine("SubNumber=" + getNumberOfRealUnderlyingSubs(odItem).ToString());
							this.writeObjectTypeLine(odSub.objectType);
							this.DCFsw.WriteLine("ParameterName=" + odSub.parameterName);
							if(dcfNode.manufacturer == Manufacturer.SEVCON)
							{
								writeDCFSectionAndObjectFields(odSub);
								writeDCFSevconMasterOnly(odSub);
							}
							#endregion  normal Item header
						}
					}
					#endregion single sub item (normal or BitSplit) or header row
				}
				else  //sub index
				{
					#region sub index (normal or Bitsplit sub)
					if(odSub.bitSplit != null) 
					{
						if(realSubsAlreadyWritten.Contains(odSub.bitSplit.realSubNo) == true)
						{
							#region the real underlying sub has alreary gone into DCF file so continue
							continue;
							#endregion the real underlying sub has already gone into DCF file so continue
						}
						else
						{
							#region write the real underlying sub to the DCF file
							realSubsAlreadyWritten.Add(odSub.bitSplit.realSubNo);
							this.DCFsw.WriteLine("[" + odIndexToWrite.ToString("X").PadLeft(4, '0') + "sub" + odSub.bitSplit.realSubNo.ToString("X") + "]"); //eg [1018sub0]
							this.DCFsw.WriteLine("ParameterName=" + odSub.bitSplit.realSubParamName);
							this.writeObjectTypeLine(odSub.objectType);
							this.writeDataTypeLine(odSub.dataType);
							this.writeAccessTypeLine(odSub.accessType, out writeInPreOpFlag);
							this.writeLowandHighLimitLines(odSub);
							this.writePDOMappingLine(odSub.PDOmappable);
							writeObjFlagsLine(odSub);
							//this.writeDCFDefaultValueLine(odSub);
							this.writeDCFRealDefaultValue(odSub.bitSplit.realSubNo, odItem); 
							this.writeDCFRealPAramValue(odSub.bitSplit.realSubNo, odItem); 
							this.writeSevconObjectVerisonLine(odSub.objectVersion);
							this.writeDCFSevconAccessLevel(odSub.accessLevel);
							writeDCfEEPROMString(odSub);
							writeDCFToolTip(odSub);
							this.writeDCFSevconWriteInPreOp(writeInPreOpFlag);
							writeBitSplitsForThisSub(odSub.bitSplit.realSubNo, odItem);  //includes writing the parameter value
							#endregion write the real underlying sub to the DCF file
						}
					}
					else
					{
						#region normal (non split subndex)
						this.DCFsw.WriteLine("[" + odIndexToWrite.ToString("X").PadLeft(4, '0') + "sub" + odSub.subNumber.ToString("X") + "]"); //eg [1018sub0]
						this.DCFsw.WriteLine("ParameterName=" + odSub.parameterName);
						this.writeObjectTypeLine(odSub.objectType);
						this.writeDataTypeLine(odSub.dataType);
						this.writeAccessTypeLine(odSub.accessType, out writeInPreOpFlag);
						this.writeLowandHighLimitLines(odSub);
						this.writePDOMappingLine(odSub.PDOmappable);
						writeObjFlagsLine(odSub);
						this.writeDCFDefaultValueLine(odSub);
						this.writeParameterValue(odSub, odItem); //Jude 021007
						this.writeSevconObjectVerisonLine(odSub.objectVersion);
						if(dcfNode.manufacturer == Manufacturer.SEVCON)
						{
							writeDCFSevconAccessLevel(odSub.accessLevel);
							writeDCFSevconScaling(odSub.scaling);
							writeDCFSevconUnits(odSub.units);
							writeDCFToolTip(odSub);
							writeDCfEEPROMString(odSub);
							this.writeDCFSevconWriteInPreOp(writeInPreOpFlag);
							this.writeDCFSevocnCommstimeout(odSub.commsTimeout);
							if(odSub.format == SevconNumberFormat.SPECIAL)
							{
								writeDCFSevconNumber_Format(odSub);
							}
							else if(odSub.format == SevconNumberFormat.BASE16)
							{
								this.DCFsw.WriteLine(";SEVCONFIELD NUMBERFORMAT=BASE16");
							}
						}
						#endregion normal (non split subndex)
					}
					#endregion sub index (normal or Bitsplit sub)
				}
				this.DCFsw.WriteLine();  //end with blank line
			}
		}


		#region utility methods fro witing individual lines an dvialues to DCF
		private ushort getNumberOfRealUnderlyingSubs(ObjDictItem odItem)
		{
			ushort numRealSubs = 0;
			ArrayList realSubs = new ArrayList();
			foreach(ODItemData odSub in odItem.odItemSubs)
			{
				if(odItem.odItemSubs.IndexOf(odSub) != 0)
				{
					#region look at all non-header subs
					if(odSub.bitSplit != null)
					{
						//pseudoSub
						if(realSubs.Contains(odSub.bitSplit.realSubNo) == false)
						{
							realSubs.Add(odSub.bitSplit.realSubNo);
							numRealSubs++;
						}
					}
					else
					{
						//real sub
						numRealSubs++;
					}
					#endregion look at all non-header subs
				}
			}
			return numRealSubs;
		}

		/* NOTE this is NUMBER_FORMAT NOT NUMBERFORMAT !!!*/
		private void writeDCFSevconNumber_Format(ODItemData odSub)
		{
			//NUMBER_FORMAT unlike NUMBERFORMAT requires us to put in the number of enumerations
			string [] enumStrs = odSub.formatList.Split(':');
			this.DCFsw.WriteLine(";SEVCONFIELD NUMBER_FORMAT=" + enumStrs.Length.ToString());
			foreach(string enumStr in enumStrs)
			{
				this.DCFsw.WriteLine(";SEVCONFIELD " + enumStr.Trim());
			}
		}
		private void writeBitSplitsForThisSub(int realSubNum, ObjDictItem odItem)
		{
			ushort splitNum = 0;
			#region calculate how many 'subs' are in this split and apend to dcf text
			//long realValue = 0;
			int numSubsInSplit = 0;
			foreach(ODItemData odSub in odItem.odItemSubs)
			{
				if((odSub.bitSplit!= null) && (odSub.bitSplit.realSubNo == realSubNum))
				{
					numSubsInSplit++;
				}
			}
			this.DCFsw.WriteLine(";SEVCONFIELD NUMBER_FORMAT=BIT_SPLIT");
			this.DCFsw.WriteLine(";SEVCONFIELD NUMBER_SPLIT=" + numSubsInSplit);

			#endregion calculate how many 'subs' are in this split

			#region calculate current vlaue for real sub and get the bitsplit text for DCf file
			foreach(ODItemData odSub in odItem.odItemSubs)
			{
				if((odSub.bitSplit!= null) && (odSub.bitSplit.realSubNo == realSubNum))
				{
					//write the bitsplit info the StringBuilder
					this.DCFsw.WriteLine(";SEVCONFIELD SPLIT=" + splitNum.ToString());
					splitNum++;
					//this.DCFsw.WriteLine(";SEVCONFIELD SPLIT=" + (odItem.odItemSubs.IndexOf(odSub)-2).ToString());
					this.DCFsw.WriteLine(";SEVCONFIELD PARAMETERNAME=" + odSub.parameterName);
					this.DCFsw.WriteLine(";SEVCONFIELD BITMASK=0x" + odSub.bitSplit.bitMask.ToString("X"));
					this.DCFsw.WriteLine(";SEVCONFIELD BITSHIFT=0x" + odSub.bitSplit.bitShift.ToString("X"));
					this.writeDCFBitsplitHighLowLimts(odSub);
					if(odSub.format == SevconNumberFormat.SPECIAL)
					{
						this.writeEnumLinesToDCF(odSub);
					}
					writeDCFSevconUnits(odSub.units);
				}
			}
			#endregion calculate current vlaue for real sub and get the bitsplit text for DCf file
		}
		private void writeDCFRealPAramValue(int realSubNum, ObjDictItem odItem)
		{
			long realValue = 0;int numSubsInSplit = 0;
			bool isBase10 = false;
			foreach(ODItemData odSub in odItem.odItemSubs)
			{
				if((odSub.bitSplit!= null) && (odSub.bitSplit.realSubNo == realSubNum))
				{
					if(odSub.accessType == ObjectAccessType.WriteOnly)
					{
						return; //If the underlying sub is write only then our 'value' is just a DW default
					}
					numSubsInSplit++;
					realValue += (odSub.currentValue << odSub.bitSplit.bitShift);
					if(odSub.format == SevconNumberFormat.BASE10)
					{
						isBase10 = true; //use that last one as an indicator
					}
				}
			}
			if(isBase10 == true)
			{
				this.DCFsw.WriteLine("ParameterValue=" + realValue.ToString());
			}
			else
			{
				this.DCFsw.WriteLine("ParameterValue=0x" + realValue.ToString("X"));
			}
		}
		private void writeDCFRealDefaultValue(int realSubNum, ObjDictItem odItem)
		{
			long realDefValue = 0;
			bool isBase10 = false;
			foreach(ODItemData odSub in odItem.odItemSubs)
			{
				if((odSub.bitSplit!= null) && (odSub.bitSplit.realSubNo == realSubNum))
				{
					realDefValue += (odSub.defaultValue << odSub.bitSplit.bitShift);
				}
			}

			if(isBase10 == true)
			{
				this.DCFsw.WriteLine("DefaultValue=" + realDefValue.ToString());
			}
			else
			{
				this.DCFsw.WriteLine("DefaultValue=0x" + realDefValue.ToString("X"));
			}

		}
		private void writeAccessTypeLine(ObjectAccessType accessType, out bool writeInPreOpFlag)
		{
			writeInPreOpFlag = false;
			switch (accessType)
			{
				case ObjectAccessType.Constant:
					this.DCFsw.WriteLine("AccessType=const");
					break;
				case ObjectAccessType.ReadOnly:
					this.DCFsw.WriteLine("AccessType=ro");
					break;
				case ObjectAccessType.ReadReadWrite:
					this.DCFsw.WriteLine("AccessType=rwr");
					break;
				case ObjectAccessType.ReadReadWriteInPreOp:
					this.DCFsw.WriteLine("AccessType=rwr");
					writeInPreOpFlag = true;
					break;
				case ObjectAccessType.ReadWrite:
					this.DCFsw.WriteLine("AccessType=rw");
					break;
				case ObjectAccessType.ReadWriteInPreOp:
					this.DCFsw.WriteLine("AccessType=rw");
					writeInPreOpFlag = true;
					break;
				case ObjectAccessType.ReadWriteWrite:
					this.DCFsw.WriteLine("AccessType=rww");
					break;
				case ObjectAccessType.ReadWriteWriteInPreOp:
					this.DCFsw.WriteLine("AccessType=rww");
					writeInPreOpFlag = true;
					break;
				case ObjectAccessType.WriteOnly:
					this.DCFsw.WriteLine("AccessType=wo");
					break;
				case ObjectAccessType.WriteOnlyInPreOp:
					this.DCFsw.WriteLine("AccessType=wo");
					writeInPreOpFlag = true;
					break;
				default : //eg ObjectAccessType.DWDisplayOnly:
					//do nothing
					break;
			}
		}

		private void writeDataTypeLine(byte datatype)
		{
			//this.DCFsw.WriteLine("DataType=0x" + datatype.ToString("X").PadLeft(2, '0')); //Jude 02Oct07 changed to match Sevcon EDS files
			this.DCFsw.WriteLine("DataType=" + datatype.ToString());
		}
		private void writeLowandHighLimitLines(ODItemData odSub)
		{
			CANopenDataType datatype = (CANopenDataType) odSub.dataType;
			switch(datatype)
			{
				case CANopenDataType.INTEGER16:
				case CANopenDataType.INTEGER24:
				case CANopenDataType.INTEGER32:
				case CANopenDataType.INTEGER40:
				case CANopenDataType.INTEGER48:
				case CANopenDataType.INTEGER56:
				case CANopenDataType.INTEGER64:
				case CANopenDataType.INTEGER8:
				case CANopenDataType.UNSIGNED16:
				case CANopenDataType.UNSIGNED24:
				case CANopenDataType.UNSIGNED32:
				case CANopenDataType.UNSIGNED40:
				case CANopenDataType.UNSIGNED48:
				case CANopenDataType.UNSIGNED56:
				case CANopenDataType.UNSIGNED64:
				case CANopenDataType.UNSIGNED8:
				case CANopenDataType.BOOLEAN:
					if(odSub.format == SevconNumberFormat.BASE10)
					{
						this.DCFsw.WriteLine("LowLimit=" + odSub.lowLimit.ToString());
						this.DCFsw.WriteLine("HighLimit=" + odSub.highLimit.ToString());
					}
					else  //assume base 16
					{
						this.DCFsw.WriteLine("LowLimit=0x" + odSub.lowLimit.ToString("X"));
						this.DCFsw.WriteLine("HighLimit=0x" + odSub.highLimit.ToString("X"));
					}
				break;

				default:
					break;

			}
		}
		private void writeDCFDefaultValueLine(ODItemData odSub)
		{
			CANopenDataType datatype = (CANopenDataType) odSub.dataType;
			switch(datatype)
			{
				case CANopenDataType.INTEGER16:
				case CANopenDataType.INTEGER24:
				case CANopenDataType.INTEGER32:
				case CANopenDataType.INTEGER40:
				case CANopenDataType.INTEGER48:
				case CANopenDataType.INTEGER56:
				case CANopenDataType.INTEGER64:
				case CANopenDataType.INTEGER8:
				case CANopenDataType.UNSIGNED16:
				case CANopenDataType.UNSIGNED24:
				case CANopenDataType.UNSIGNED32:
				case CANopenDataType.UNSIGNED40:
				case CANopenDataType.UNSIGNED48:
				case CANopenDataType.UNSIGNED56:
				case CANopenDataType.UNSIGNED64:
				case CANopenDataType.UNSIGNED8:
				case CANopenDataType.BOOLEAN:
					if(odSub.format == SevconNumberFormat.BASE16)
					{
						#region Base 16
						switch(odSub.defaultType)
						{
							case defaultValType.NORMAL:
							{
								this.DCFsw.WriteLine("DefaultValue=0x" + odSub.defaultValue.ToString("X"));
								break;
							}
							case defaultValType.NODEID_ADDED:
							{
								this.DCFsw.WriteLine("DefaultValue=$NODEID+0x" + (odSub.defaultValue - odSub.CANnode.nodeID).ToString("X"));
								break;
							}
							default: //NONE
							{
								break;
							}
						}
						#endregion Base 16
					}
					else //assume base 10
					{
						#region base 10
						switch(odSub.defaultType)
						{
							case defaultValType.NORMAL:
							{
								this.DCFsw.WriteLine("DefaultValue=" + odSub.defaultValue.ToString());
								break;
							}
							case defaultValType.NODEID_ADDED:
							{
								this.DCFsw.WriteLine("DefaultValue=$NODEID+" + (odSub.defaultValue - odSub.CANnode.nodeID).ToString());
								break;
							}
							default: //NONE
							{
								break;
							}
						}
						#endregion base 10
					}
					break;

				default:
					break;

			}
		}
		private void writePDOMappingLine(bool pdoMappable)
		{
			if(pdoMappable == true)
			{
				this.DCFsw.WriteLine("PDOMapping=1");
			}
			else
			{
				this.DCFsw.WriteLine("PDOMapping=0");
			}
		}
		private void writeSevconObjectVerisonLine(ushort objectVersion)
		{
			this.DCFsw.WriteLine(";SEVCONFIELD OBJECT_VERSION=" + objectVersion.ToString());
		}
		private void writeObjFlagsLine(ODItemData odSub)
		{
			if(odSub.objFlags != 0)
			{
				this.DCFsw.WriteLine("ObjFlags=0x" + odSub.objFlags.ToString("X"));
			}
		}
		private void writeObjectTypeLine(byte objectType)
		{
			//this.DCFsw.WriteLine("ObjectType=0x" +objectType.ToString("X").PadLeft(2, '0'));  //Jude 02 Oct 07 changed to match Sevcon EDS files
			this.DCFsw.WriteLine("ObjectType=" +objectType.ToString());
		}
		private void writeSingleSubBitSplitToDCF(ODItemData firstSub, ObjDictItem odItem, bool writeInPreOpFlag)
		{
			this.DCFsw.WriteLine(";SEVCONFIELD NUMBER_FORMAT=BIT_SPLIT");
			this.DCFsw.WriteLine(";SEVCONFIELD NUMBER_SPLIT="+ (odItem.odItemSubs.Count -2).ToString());
			foreach(ODItemData odSub in odItem.odItemSubs)
			{
				if(odItem.odItemSubs.IndexOf(odSub) <2)
				{
					continue; //ignore header and num items
				}
				this.DCFsw.WriteLine(";SEVCONFIELD SPLIT=" + (odItem.odItemSubs.IndexOf(odSub)-2).ToString());
				this.DCFsw.WriteLine(";SEVCONFIELD PARAMETERNAME=" + odSub.parameterName);
				this.DCFsw.WriteLine(";SEVCONFIELD BITMASK=0x" + odSub.bitSplit.bitMask.ToString("X"));
				this.DCFsw.WriteLine(";SEVCONFIELD BITSHIFT=0x" + odSub.bitSplit.bitShift.ToString("X"));
				this.writeDCFBitsplitHighLowLimts(odSub);
				if(odSub.format == SevconNumberFormat.SPECIAL)
				{
					this.writeEnumLinesToDCF(odSub);
				}
				this.writeDCFSevconUnits(odSub.units); //each split can have its own units
			}
		}
		private void writeDCFSevconAccessLevel(byte accessLevel)
		{
			if(accessLevel>0)
			{
				this.DCFsw.WriteLine(";SEVCONFIELD ACCESS_LEVEL=" + accessLevel.ToString());
			}
		}
		private void writeDCFSevconWriteInPreOp(bool writeInPreOpFlag)
		{
			if(writeInPreOpFlag == true)  //applied to all pseudo subs
			{
				this.DCFsw.WriteLine(";SEVCONFIELD WRITE_IN_PREOPERATIONAL_ONLY=TRUE");
			}
		}
		private void writeDCFSevconScaling(double scaling)
		{
            if (scaling != 1)
            {
                //Jude DR000234 Apply InvariantCulture to all convertsions between strings and floats/doubles/reals
                this.DCFsw.WriteLine(";SEVCONFIELD SCALING=" + scaling.ToString("R", CultureInfo.InvariantCulture.NumberFormat)); //use round trip for now
            }
        }
		private void writeDCFSevconUnits(string units)
		{
			if(units != "")
			{
				this.DCFsw.WriteLine(";SEVCONFIELD UNITS=" + units);
			}
		}
		private void writeDCFSevocnCommstimeout(int commsTimeout)
		{
			if(commsTimeout != SCCorpStyle.TimeoutDefault)
			{
				this.DCFsw.WriteLine(";SEVCONFIELD COMMS_TIMEOUT=" + commsTimeout.ToString());
			}

		}

		private void writeDCFToolTip(ODItemData odSub)
		{
			if(odSub.tooltip != "")
			{
				this.DCFsw.WriteLine(";SEVCONFIELD TOOLTIP=" + odSub.tooltip);
			}
		}
		private void writeDCfEEPROMString(ODItemData odSub)
		{
			if(odSub.eepromString != "")
			{
				this.DCFsw.WriteLine(";SEVCONFIELD EEPROM=" + odSub.eepromString);
			}
		}
		private void writeDCFSectionAndObjectFields(ODItemData odSub)
		{
            this.DCFsw.WriteLine(";SEVCONFIELD OBJECT=" + odSub.objectNameString);
            this.DCFsw.WriteLine(";SEVCONFIELD SECTION=" + odSub.sectionTypeString);
		}

		private void writeDCFSevconMasterOnly(ODItemData odSub)
		{
			if(odSub.displayOnMasterOnly == true)
			{
				this.DCFsw.WriteLine(";SEVCONFIELD MASTER=TRUE");
			}
		}
		private void writeEnumLinesToDCF(ODItemData odSub)
		{
			this.DCFsw.WriteLine(";SEVCONFIELD NUMBERFORMAT=2");

			string [] enumStrs = odSub.formatList.Split(':');
			foreach(string enumStr in enumStrs)
			{
				this.DCFsw.WriteLine(";SEVCONFIELD " + enumStr.Trim());
			}
		}
		private void writeDCFBitsplitHighLowLimts(ODItemData odSub)
		{
			if (odSub.format == SevconNumberFormat.BASE10)
			{
				this.DCFsw.WriteLine(";SEVCONFIELD LOW_LIMIT=" + odSub.bitSplit.lowLimit.ToString());
				this.DCFsw.WriteLine(";SEVCONFIELD HIGH_LIMIT=" + odSub.bitSplit.highLimit.ToString());
				this.DCFsw.WriteLine(";SEVCONFIELD NUMBERFORMAT=BASE10");
			}
			else 
			{
				this.DCFsw.WriteLine(";SEVCONFIELD LOW_LIMIT=0x" + odSub.bitSplit.lowLimit.ToString("X"));
				this.DCFsw.WriteLine(";SEVCONFIELD HIGH_LIMIT=0x" + odSub.bitSplit.highLimit.ToString("X"));
				if (odSub.format == SevconNumberFormat.BASE16)
				{
					this.DCFsw.WriteLine(";SEVCONFIELD NUMBERFORMAT=BASE16");
				}
			}
		}
		//-------------------------------------------------------------------------
		//  Name			: writeDCFChecksum(string EDSorDCFfilepath)
		//  Description     : Calculates and appends the checksum of the DCF file
		//					  currently open.
		//  Parameters      : None
		//  Used Variables  : sr - DCF file stream reader
		//					  DCFsw - DCF file stream writer
		//  Preconditions   : A DCF file has just been generated by DriveWizard
		//					  and the sr and DCFsw are still open. The file needs
		//					  its checksum to be calculated and appended.
		//  Post-conditions : The DCF file currently open has had the checksum
		//					  calculated and appended to the file.
		//  Return value    : Indicates success or gives a failure reason.
		//--------------------------------------------------------------------------
		///<summary>Calculates and appends the checksum of the DCF file currently open.</summary>
		/// <returns>feedback inicates success or gives a failure reason</returns>
		public DIFeedbackCode writeDCFChecksum(string EDSorDCFfilepath)
		{
			#region local variable declaration and initialisation
			DIFeedbackCode fbc = DIFeedbackCode.DIFailedToWriteDCFChecksum;
			UInt32 DCFChecksum = 0x0000;
			string line;
			#endregion

			try
			{
				// if the DCF file stream writer and readers are initialised
				// rewind the stream reader back to the start of the DCF file
				rewind(EDSorDCFfilepath, FileAccess.ReadWrite);
				// calculate the DCF file checksum
				while ( ( line = EDSorDCFsr.ReadLine() ) != null )
				{
					for ( int b = 0; b < line.Length; b++ )
					{
						DCFChecksum += (UInt32)line[ b ];
					}

					// account for carriage return and line feed
					DCFChecksum = DCFChecksum + 0x0d + 0x0a;
				}

				/* Format is ;SEVCONFIELD FILE_CHECKSUM=0x234489
					 * Blank line already put in after last parameter value automatically.
					 */
				//DCFsw.WriteLine( "" ); 
					
				// account for carriage return and line feed put after last parameter
				DCFChecksum = DCFChecksum - 0x0d - 0x0a;

				DCFsw.WriteLine( ";SEVCONFIELD FILE_CHECKSUM=0x" + DCFChecksum.ToString( "x" ) );
				DCFsw.Flush();

				fbc = DIFeedbackCode.DISuccess;
			}
			catch ( Exception e )
			{
				fbc = DIFeedbackCode.DIFailedToWriteDCFChecksum;
				SystemInfo.errorSB.Append("\nFailed to write DCF checksum: Error Code");
				SystemInfo.errorSB.Append(e.Message);
			}
			return ( fbc );
		}

		#endregion utility methods fro witing individual lines an dvialues to DCF
		#endregion methods for writing all sections to a DCF file

		#region methods for reading DCF specific file items
		///-------------------------------------------------------------------------
		///  Name			: readCommissioningInfo()
		///  Description     : This function reads the commissioning section of the
		//					  DCF file and stores the pertinent information into the
		//					  DCFCommissioningInfo structure, comInfo.
		//  Parameters      : None
		//  Used Variables  : comInfo - data structure used to contain the 
		//								commissioning information of the DCF file.
		//  Preconditions   : The DCF file has been selected by the GUI and has
		//					  already been successfully opened for reading.
		//  Post-conditions : The comInfo data structure is populated with the
		//					  pertinent information found in the DCF commissioning
		//					  section of the DCF file of DCFfilename.
		//  Return value    : fbc - success or indicates a failure reason
		//--------------------------------------------------------------------------
		///<summary>Reads the commissioning section of the opened DCF file.</summary>
		/// <returns>feedback indicates success or gives a failure reason</returns>
		/// 
		public DIFeedbackCode readDCFCommissioningInfo( string filepath)
		{
			this.comInfo = new DCFCommissioningInfo();
			#region local variable declarations
			DIFeedbackCode fbc = DIFeedbackCode.DIFailedToReadDCFCommissioningInfo;;
			string input;
			string upperCaseInput;
			bool sectionEnd = false;
			#endregion

			// rewind back to the beginning of the file
			rewind(filepath, FileAccess.Read);
			#region while not EOF & not read device commissioning section, read & parse next line
			while ( ( input = readLine() ) != null )
			{
				#region make case insensitive and remove part line comments
				upperCaseInput = input.ToUpper();
				removePartLineComments( upperCaseInput );  //the line we are looking for has no associated valueSubString
				#endregion

				#region if DEVICECOMMISSIONING section found parse to extract relevant info
				if 
					( 
					( upperCaseInput.IndexOf( "[DEVICECOMMISSIONING]" ) != -1 )
					|| ( upperCaseInput.IndexOf( "[DEVICECOMISSIONING]" ) != -1 )
					)
				{
					fbc = DIFeedbackCode.DISuccess;

					#region while not end of device comm section, read & parse next line of file
					while ( ( input = readLine() ) != null )
					{
						string valueSubString = this.getvalueSubString(input);
						#region make case insensitive and remove part line comments
						upperCaseInput = input.ToUpper();
//						removePartLineComments(  upperCaseInput );
						#endregion

						#region if end of device comm section found then quit this loop
						if ( sectionEnd = endOfSection ( input ) ) 
						{
							break;
						}
							#endregion
							#region else if NODEID found extract & convert to an int
						else if ( upperCaseInput.IndexOf( "NODEID" ) != -1 )
						{
							comInfo.nodeID = (int)sysInfo.convertToUint(valueSubString);
						}
							#endregion
							#region else if BAUDRATE found extract & convert to BaudRate enum type
						else if ( upperCaseInput.IndexOf( "BAUDRATE" ) != -1 )
						{
							#region conver the vlaue string to Enum Baudrate
							int baudRate = (int)sysInfo.convertToUint(valueSubString);
							comInfo.baudRate  = BaudRate._unknown;
							for ( int b = 0; b < baudRateAsInts.Length; b++ )
							{
								if ( baudRateAsInts[ b ] == baudRate )
								{
									comInfo.baudRate = (BaudRate)b;
								}
							}
							#endregion conver the vlaue string to Enum Baudrate
						}
							#endregion
							#region else if nodename found, extract (keep as string)
						else if ( upperCaseInput.IndexOf( "NODENAME" ) != -1 )
						{
							comInfo.nodeName = input.Trim().Substring(input.IndexOf( "=" ) + 1);
						}
							#endregion
							#region else if netnumber found, extract & convert to int
						else if ( upperCaseInput.IndexOf( "NETNUMBER" ) != -1 )
						{
							comInfo.netNumber = (int)sysInfo.convertToUint(valueSubString);
						}
							#endregion 
							#region else if network name found, extract (keep as string)
						else if ( upperCaseInput.IndexOf( "NETWORKNAME" ) != -1 )
						{
							comInfo.networkName = input.Trim().Substring(input.IndexOf( "=" ) + 1);
						}
							#endregion
							#region else if lss serial no found, extract & convert to int
						else if ( upperCaseInput.IndexOf( "LSS_SERIALNUMBER" ) != -1 )
						{
							comInfo.LSS_SerialNumber = (int)sysInfo.convertToUint(valueSubString);
						}
						#endregion
					}
					#endregion
				
					#region if found end of device commissioning section then quit file read loop
					if ( sectionEnd )
					{
						break;
					}
					#endregion
				}
				#endregion
			}
			#endregion

            //DR38000260 - additional error feedback
            if ((fbc != DIFeedbackCode.DISuccess) && (MAIN_WINDOW.appendErrorInfo == true))
            {
                SystemInfo.errorSB.Append("\nFormat error in [DeviceComissioning] section.");
            }
            return ( fbc );
		}

		//-------------------------------------------------------------------------
		//  Name			: readCompactObjParameterValues()
		//  Description     : This function reads a series of objects which have
		//					  already been determined to be in the compact format. The
		//					  EDS stores this differently to normal object definitions
		//					  and this must be carried through to the DCF.
		//  Parameters      : currentLine - last line of ASCII text read from the file
		//					  objectIdentifier - object index (as ASCII string) to be read
		//							from file in expected compact format
		//					  tempData - instance of the EDSObjectInfo used to store
		//							the information read in from the file which was
		//							in compact object format
		//  Used Variables  : None
		//  Preconditions   : A DCF file has been opened for read or write and an object
		//					  of objectIdentifier is to be read but it could be in
		//					  compact object format.
		//  Post-conditions : If the objectIdentifier object was in compact object format
		//					  then it's pertinent details are read in from the file and
		//					  copied into the tempData structure which is returned by
		//					  referernce.
		//  Return value    : fbc - success or indicates a failure reason
		//--------------------------------------------------------------------------
		///<summary>Reads a series of objects which are already known to be in the compact format in the DCF file.</summary>
		/// <param name="currentLine">last line of ASCII text read from the file</param>
		/// <param name="objectIdentifier">object index (as ASCII string) to be read from
		/// file in expected compact format</param>
		/// <param name="tempData">instance of the EDSObjectInfo used to store the information 
		/// read in from the file which was in compact object format</param>
		/// <returns>feedback indicates success or gives a failure reason</returns>
		public DIFeedbackCode readCompactObjParameterValues( string currentLine, string objectIdentifier, EDSObjectInfo tempData )
		{
			#region local variable declarations
			DIFeedbackCode fbc = DIFeedbackCode.DIGeneralFailure;
			string input;
			string upperCaseInput;
			int noOfEntries = 0;
			int entriesRead = 0;
			#endregion
            
			#region if this line contains a compact parameter value then read all the sub compacts
			objectIdentifier = objectIdentifier.Trim( ']' );
							
			if ( ( currentLine.IndexOf( objectIdentifier + "VALUE]" ) != -1 )&& ( tempData.compactObj == true ) )
			{
				#region while not EOF & not end of section, read compact entries
				while ( ( input = readLine() ) != null )
				{
					string valueSubString = this.getvalueSubString(input);
					#region make case insensitive & remove part line comments (could be confusing)
					upperCaseInput = input.ToUpper();
//					removePartLineComments( upperCaseInput );
					#endregion

					#region if end of compact value section is found then quit this loop
					if ( endOfSection ( input) )
					{
						break;
					}
						#endregion
						#region else if number of entries then extract & convert to int
					else if ( upperCaseInput.IndexOf( "NROFENTRIES" ) != -1 )
					{
						noOfEntries = (int)sysInfo.convertToUint(valueSubString);
						tempData.parameterValue = new string[ noOfEntries ];
						entriesRead = 0;
					}
						#endregion
						#region else if parameter value then extract (keep as string till know data type)
					else if ( upperCaseInput.IndexOf( "=" ) != -1 )
					{
						// if not read all values expected then add latest to the list
						if ( entriesRead < tempData.parameterValue.Length )
						{
							tempData.parameterValue[ entriesRead ] = input;
							entriesRead++;
						}
							// else unexpected value so quit (error in DCF file)
						else
						{
							break;
						}
					} 
					#endregion
				} 
				#endregion
			} 
			#endregion

            //DR38000260 - additional error feedback
            if ((noOfEntries != entriesRead) || (noOfEntries == 0))
            {
                fbc = DIFeedbackCode.DIInvalidCompactObjectFormat;

                if (MAIN_WINDOW.appendErrorInfo == true)
			    {
				    SystemInfo.errorSB.Append("\nFormat error in compact obj definition.");
			    }
            }
			return ( fbc );
		}

		//-------------------------------------------------------------------------
		//  Name			: verifyDCFChecksumOK()
		//  Description     : Reads the DCF file and calculates the file checksum.
		//					  This is then compared to the file checksum read from
		//					  the file itself to determine whether it is valid.
		//  Parameters      : None
		//  Used Variables  : sr - DCF file stream reader
		//  Preconditions   : The DCF file which the checksum is to be verified in
		//					  is already open for reading.
		//  Post-conditions : checksumOK is set appropriately for the return value
		//  Return value    : checksumOK is true if the calculated DCF checksum is
		//					  the same as the checksum read from the file
		//--------------------------------------------------------------------------
		///<summary>Reads a DCF file, calculates the checksum and validates it against the checksum contained within the file itself.</summary>
		/// <returns>true if the calculated DCF checksum is the same as the checksum
		/// read from the file</returns>
		public bool verifyDCFChecksumOK(string EDSorDCFfilepath)
		{
			#region local variable declaration and initialisation
			bool checksumOK = false;
			string input;
			UInt32 DCFChecksum = 0x0000;
			UInt32 calculatedChecksum = 0x0000;
			#endregion

			try
			{
				// if the DCF file stream reader is initialised
				if ( EDSorDCFsr != null )
				{
					// rewind the stream reader back to the start of the DCF file
					rewind(EDSorDCFfilepath, FileAccess.Read);

					// read the DCF file, line at a time
					while ( ( input = EDSorDCFsr.ReadLine() ) != null )
					{
						#region if this line contains the file written checksum, then extract it
						if ( input.IndexOf( "SEVCONFIELD FILE_CHECKSUM" ) != -1 )
						{
							string valueSubString = this.getvalueSubString(input);
							/* Need to remove the carriage return and line feed characters
							 * between the end of the DCF file proper and the line with
							 * the checksum in it.
							 * This is because the DCF file generator calculates the
							 * file checksum then appends a blank line and the line
							 * with SEVCONFIELD FILE_CHECKSUM=0xyyyyy to the file.
							 * THESE ADDITIONAL CHARACTERS ARE NOT INCLUDED WHEN
							 * CALCULATING THE CHECKSUM.
							 * Hence, we've accidently added in the CR and LR between
							 * the end of the DCF file proper and before the checksum
							 * line so we must now remove them again.
							 */
							calculatedChecksum = calculatedChecksum - 0xa - 0x0d;

							DCFChecksum = sysInfo.convertToUint(valueSubString);
						}
							#endregion
							#region else update the calculated checksum with data in this line of the file
						else
						{
							// update checksum for each byte in this line of the file
							for ( int b = 0; b < input.Length; b++ )
							{
								calculatedChecksum += (UInt32)input[ b ];
							}

							/* Carriage return and line feed added back into checksum 
							 * as ReadLine strips them out.
							 */
							calculatedChecksum += 0x0d;
							calculatedChecksum += 0x0a;
						}
						#endregion
					}

					// Does the calculated checksum match the checksum read from the DCF file?
                    if (calculatedChecksum == DCFChecksum)
					{
						checksumOK = true;
					}
				}
			}
			catch ( Exception e )
			{
				SystemInfo.errorSB.Append("\nFailed to verify DCF checksum. Error: ");
				SystemInfo.errorSB.Append(e.Message);
			}

            //DR38000260 - additional error feedback
            if ((checksumOK == false) && (DCFChecksum != 0x0000) && (MAIN_WINDOW.appendErrorInfo == true))
            {
                SystemInfo.errorSB.Append("\nInvalid checksum in DCF file.");
            }

			return ( checksumOK );
		}
		#endregion methods for reading DCF specific file items

		#region dcf domain file
		//-------------------------------------------------------------------------
		//  Name			: readDomainFile()
		//  Description     : This function reads the Sevcon log which was stored in
		//					  the DCF associated file (///.dmn text file) which contains
		//					  the raw byte data in ASCII hex format and converts it back
		//					  into a byte array.
		//  Parameters      : edsInfo - the eds infomation which contains the domain 
		//								filename as the parameter value for a domain object
		//					  thisEDS - EDSorDCF object reference so that the EDS conversion
		//								routines for Sevcon object and section type can
		//								be used 
		//					  currentValueDomain - byte array reconstructed from the .dmn
		//								file
		//  Used Variables  : None
		//  Preconditions   : edsInfo is a CANOpenDisplayType of domain type and the
		//					  parameterValue contains the name of the .dmn text file
		//					  containing the uploaded & saved byte array.
		//  Post-conditions : currentValueDomain contains the raw byte array as read in
		//					  from the .dmn file (converted from ASCII hex format).
		//  Return value    : fbc - DISuccess if .dmn file read OK otherwise a failure code
		//							indicating the reason for failure.
		//----------------------------------------------------------------------------
		///<summary>Reads the domain file (*.dmn) associated with a DCF file (format defined by DW).</summary>
		/// <param name="edsInfo">the eds infomation which contains the domain filename as the parameter 
		/// value for a domain object </param>
		/// <param name="thisEDS">EDSorDCF object reference so that the EDS conversion routines for 
		/// Sevcon object and section type can be used</param>
		/// <param name="currentValueDomain">byte array reconstructed from the .dmn file</param>
		/// <returns>feedback code indicates success or gives a failure reason</returns>
		internal DIFeedbackCode readDomainFile( EDSObjectInfo edsInfo, EDSorDCF thisEDS, byte[] currentValueDomain)
		{
			#region local variable declaration and variable initialisation
			DIFeedbackCode fbc = DIFeedbackCode.DIGeneralFailure;
			StreamReader sr = null;
			FileStream	fs = null;
			string input;
			string searchString;
			string [] split;
			byte [] bytes = null;
			byte [] line;
			bool endSection = false;

			// Initialise currentValue to null until found otherwise & stops compiler complaining.
			currentValueDomain = null;
			#endregion

			#region if domain file exists then read it and extract the byte array (from ASCII hex)
			if ( File.Exists( edsInfo.parameterValue[ 0 ] ) )
			{
				#region attempt to create stream readers
				try
				{
					// Open the domain file which is stored in the EDS as a parameter for the domain.
					fs = new FileStream( edsInfo.parameterValue[ 0 ], System.IO.FileMode.Open, System.IO.FileAccess.Read );
					sr = new StreamReader( fs );
				}
				catch ( Exception e )
				{// we can use the global string builder here - its only called when opening a DCF file
					SystemInfo.errorSB.Append("Failed to open file: " );
					SystemInfo.errorSB.Append(edsInfo.parameterValue[ 0 ]);
					SystemInfo.errorSB.Append("error code: ");
					SystemInfo.errorSB.Append(e.Message);
					return  DIFeedbackCode.DIUnableToReadDCFFile;
				}
				#endregion attempt to create stream readers

				#region build up search string of index and sub of interest
				/* Format for Sevcon logs augments the raw bytes data with the index and sub which
					 * it represents (so that more than one domain object can be stored in this file)
					 * and also contains the Sevcon section and object strings.
					 * 
					 * Search for the correct object section within this domain file.
					 */
				searchString = "[" + edsInfo.indexNumber.ToString("X") + "sub" + edsInfo.subNumber.ToString("X") + "]";
				#endregion

				#region find the section header of the index and sub of interest
				/* Read each line of the domain file in until we find the section header for the
					 * index and sub representing the log of interest.
					 */
				while ( ( input = sr.ReadLine() ) != null )
				{
					if ( input.IndexOf( searchString ) != -1 )
					{
						fbc = DIFeedbackCode.DISuccess;
						break;
					}
				}
				#endregion

				// If the section is found then read in the hex data (ASCII hex format, space delimited).
				while ( ( input = sr.ReadLine() ) != null )
				{
					
					string valueSubString = this.getvalueSubString(input);
						#region Convert to upper case to make case independent.
						input = input.ToUpper();
					#endregion

					if(input == "")
					{
						#region do nothing
						#endregion do nothing
					}
						
					else if ( input.IndexOf( "[END_SECTION]" ) != -1 )
					{
						#region if the end of section marker is found then quit the loop.
						endSection = true;
						break;
						#endregion
					}
					else if ( input.IndexOf( "SEVCONFIELD OBJECT" ) != -1 )
					{
						#region if Sevcon object type found in the domain file, read it in
						edsInfo.objectName = thisEDS.readSevconObjectType( valueSubString.ToUpper()  );
						#endregion if Sevcon object type found in the domain file, read it in
					}
					else if ( input.IndexOf( "SEVCONFIELD SECTION" ) != -1 )
					{
						#region else if Sevcon section type found in the domain file, read it
						edsInfo.sectionType = thisEDS.readSectionType( valueSubString.ToUpper() );
						#endregion
					}
					else
					{
						#region else read in the ASCII hex space delimited raw data bytes
						/* Else it must be the space delimited ASCII hex representing the raw
								 * data bytes.
								 */
						// Data is expected to be space delimited of unknown length but in ASCII hex format
						input = input.Trim();
						string delimStr = ",";
						char [] delimiter = delimStr.ToCharArray();

						split = input.Split(delimiter);
						line = new byte[ split.Length ];

						// for each byte in the line convert from ASCII back to a byte.
						for ( int i = 0; i < split.Length; i++ )
						{
							#region try to convert to byte
							split[i] = split[i].Trim();
							try
							{
								line[ i ] = System.Convert.ToByte( split[ i ], 16 );
							//		line[ i ] = System.Convert.ToByte( "0XF0", 16 );
							}
							catch ( Exception )
							{
								SystemInfo.errorSB.Append( "/nError in DCF domain" + line[ i ] + "str=" + input);
							}
							#endregion try to convert to byte
						}

						// Resize the bytes array to add the latest line data in.
						try
						{
							#region resize bytes array
							int dataSize;

							if ( bytes != null )
							{
								dataSize = bytes.Length + line.Length;
								byte [] newArray = new byte[ dataSize ];
								bytes.CopyTo( newArray, 0 );
								line.CopyTo( newArray, bytes.Length );
								bytes = newArray;
							}
								// First line so no need to resize etc.
							else
							{
								bytes = line;
							}
							#endregion resize bytes array
						}
						catch ( Exception )
						{
							fbc = DIFeedbackCode.DIOutOfODMemory;
							break;
						}
					#endregion  else read in the ASCII hex space delimited raw data bytes	
					} // end of if then else statment
					
				} // end of while not end of section and not null line

				#region set current value and feedback code
				/* If the section was found OK and read in correctly until the end of the
					 * section was found then it is safe to say the domain file read was a 
					 * success.  Assign the out value with the read in & converted bytes array.
					 */
				if ( endSection == true )
				{
					currentValueDomain = bytes;
					fbc = DIFeedbackCode.DISuccess;
				}
				#endregion

				#region if the stream reader is open then close it now we're finished.
				if ( sr != null )
				{
					sr.Close();
					sr = null;
				}
				#endregion

				#region if the file stream  is open then close it now we're finished.
				if ( fs != null )
				{
					fs.Close();
					fs = null;
				}
				#endregion
			}
				#endregion
				#region else if .dmn file doesn't exist so return failure code to let the user know.
			else
			{
				fbc = DIFeedbackCode.DIInvalidFilename;
			}
			#endregion

            //DR38000260 - additional error feedback
            if ((fbc != DIFeedbackCode.DISuccess) && (MAIN_WINDOW.appendErrorInfo == true))
            {
                SystemInfo.errorSB.Append("\nInvalid domain format in DCF file.");
            }
			return ( fbc );
		}
		#endregion  dcf domain file
	}
}
